<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《微信背后的产品观》-读书分享]]></title>
    <url>%2F2023%2F05%2F04%2FreadBookOfWeixin%2F</url>
    <content type="text"><![CDATA[最近又重新刷了一遍《微信背后的产品观》，遂有了如下的一些感想，就权当记录一下吧！部分内容是书中摘抄，建议有机会可以看看原书！ 作者及内容简介张小龙的三个产品：foxmail、qq邮箱、微信本书的内容是张小龙在2012年一个内部公开演讲内容，整理成书。内容分为了用户篇、需求篇、设计篇、气质篇、UI篇和提问环节。包含了作者对产品和世界的底层运行逻辑的理解，对群体、规则、趋势的看法和态度。分享前的思考 为什么微信没有做信息已读的功能？ 为什么微信启动图片是一个人在月球看地球的图片？ 为什么微信要做漂流瓶的功能？ 为什么微信要做朋友圈？ 用户篇人是懒惰的。懒惰也催生了很多发明，问题是我们的产品里如何应用这个观点，做出适当的功能特性。（可以试试微信的语音播放功能）人是没有耐心的。用户不会去看产品说明书，买回来一件商品，说明书立马就会被扔到一旁。如果不能让用户一分钟就爱上你的产品，以后可能就不会再来用了。从性能方面看就如同用户在几秒钟内打不开网站、白屏时间过长，用户就会离开一样，就会造成用户流失。产品设计过程中要考虑人性化，人性化就是以己推人。产品设计出来终究是给人用的，所以要去研究人，就要学会以己推人。假设自己就是用户，自己都很懒，不喜欢看说明书，不喜欢复杂冗余的功能体验，通过自己，或许就理解了人们最普遍的心理。所以，在产品设计里，我们往往是靠着自己的感觉来做决定的。从日常体验中发现本质。要有意识的在生活中去发现产品设计背后的一些思想，使用一个功能的时候，去思考为什么要如此设计，有没有更好的设计方式，在不断的体验过程中去感受产品功能设计。假如一个功能做出来，自己都不想使用，那这个功能设计就是失败的。 需求篇不要用户说什么就去做什么。用户的反馈只是帮助你了解到他们的想法，而用户的需求是零散的，解决方案是归纳抽象的过程。我们要做的是透过用户的想法，了解背后用户真正的诉求点，即找到需求背后的本质需求。做产品应该首先去考虑的是：我们不是在做一个功能，而是要怎么满足用户的诉求，最终的落脚点还是用户，是使用产品的人。 设计篇先做产品结构，之后才是功能细节。不必一开始就追求大而全，做好主体结构之后在不断迭代完善细节。设计、分类，归纳总结。抽象方能化繁为简。如果我们有100个需求，我们可以将其变成10个需求，从而派生出100个需求，就做了一个很好的抽象，如果能汇总成一个需求就更好了，找到不同需求之间的共性，进行处理。这样程序员才不会被累死！！！越简单的分类越容易被接受。保持简单。把用户体验做到极致就是创新。例如：把手机放到耳朵旁边，微信语音的声音会切换到从听筒出来。不要过度设计，不要过度设计，不要过度设计，重要的事情说三遍，设计是为了更好的体验。需要用文字解释的功能不是好体验。 最后谈谈朋友圈。站在今天看朋友圈的设计，大家可能觉得很简单，人们发发文字、晒晒图片，然后朋友点赞评论，so easy。你有没有一种感觉，自己一下午就能把设计稿画出来？ 朋友圈是微信4.0的一个重要功能，在书里有大量的案例是围绕着朋友圈展开的，设计之精妙，叹为观止。例如，我们刷朋友圈会有这样的感觉，划了几屏，都没看到一个评论和点赞，是大家的活跃度降低了吗？可能是，也可能不是，这就和朋友圈的产品设计逻辑有很大的关系。 大家可能因为各种各样的原因加了好多微信好友，但实际上经常联系的人也就那么几个，不会超过100，而每天都说话的可能都没有10个，剩下的人大部分都是弱关系、弱连接。假如弱关系的朋友发了一个朋友圈，他的朋友点赞或者评论，你就会看不到，而这就是朋友圈的设计规则，这一点和微博有很大的不同。 我们经常看到一个人在默默的发朋友圈，自己看着一条评论或点赞都没有，以为人家在自言自语，可能是、也可能不是，或许人家一堆评论、点赞，而你根本就看不到。即使整个朋友圈都没有点赞和评论了，甚至你自己发的东西也没有点赞和评论了，你也不必觉得尴尬，可能你并没有很多朋友，但别人也不知道。 作者认为他要做的朋友圈是私密的，可以很方便地跟好友互动，但是又觉得很舒适，没有心理上的压力。 思考答案 为什么微信没有做信息已读的功能？张小龙不喜欢，觉得对自己有压力。 为什么微信启动图片是一个人在月球看地球的图片？（据说第一个版本是站在地球看月球）让人们看到了孤独感，而孤独是永恒的主题。 为什么微信要做漂流瓶的功能？是想帮人解决倾诉和好奇的欲望，其次才是交友的欲望。 为什么微信要做朋友圈？大家的内心可能缺少一些东西，这种时候就需要用另一种形式来满足自己的内心，可以是存在感，可以是自我价值认同感，人们需要在朋友的关注里存在。而手机因为随时随地的特性，便成了最好的媒介。 每个人都会有自己解决问题的办法，没有永远正确的教条。—张小龙我所说的，都是错的。—张小龙]]></content>
      <categories>
        <category>book</category>
      </categories>
      <tags>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise链式调用特性总结]]></title>
    <url>%2F2020%2F09%2F05%2FpromiseArticle1%2F</url>
    <content type="text"><![CDATA[相信各位前端小伙伴对于Promise应该很熟悉了吧，日常工作中，100%会用到的一个东西，除非你还在用callback解决异步，那我就太佩服了。话不多说，进入正题。 提前声明一下，以下代码在node环境中实现，你可以创建一个文件，使用nodemon这个工具执行这个文件，就可以进行监听更新，真香。 首先你要创建一个promise123let p=new Promise((resolve,reject)=&gt;&#123; resolve(&apos;first resolve&apos;)&#125;) 方式一、通过return传递结果12345p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; console.log(res)&#125;) 控制台就会输出：first resolve 方式二、通过返回新的promise resolve结果123456789p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; resolve(&apos;second resolve: &apos;+res) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;) 控制台就会输出：second resolve: first resolve如果在返回的promise里加一个异步比如settimeout呢，结果会是什么样？123456789101112p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; // resolve(&apos;second resolve: &apos;+res) setTimeout(()=&gt;&#123; resolve(&apos;second resolve: &apos;+res) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;) 控制台等待2s后输出：second resolve: first resolve 方式三、通过返回新的promise reject 原因既然可以通过新的promise resolve，那么reject应该也可以。12345678910111213p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err)&#125;) 控制台等待2s后输出：error: error 方式四、then函数走了失败回调继续走then紧接着上一步，失败后，reject出原因，继续后面then123456789101112131415161718p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err) // 默认 return undefined&#125;).then(res=&gt;&#123; console.log(&apos;second then success: &apos;+res)&#125;,err=&gt;&#123; console.log(&apos;second then error: &apos;+err)&#125;) 控制台会输出两行内容：error: error，second then success: undefined。这就表明在reject 后面继续then会执行下一步的resolve，如果上一步没有返回值，默认接收undefined。 方式五、then中使用throw new Error情况如果在then中抛出异常呢，如何显示？12345678910111213141516171819p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err)&#125;).then(res=&gt;&#123; throw new Error(&apos;happend error&apos;)&#125;).then(res=&gt;&#123; console.log(&apos;third then success&apos;+res)&#125;,err=&gt;&#123; console.log(&apos;third then error &apos;+err)&#125;) 控制台会输出：error: errorthird then error Error: happend error这表明throw error抛出异常类似reject，会由下一步的then方法中的错误方法处理。 方式六、在promise中使用catch进行错误捕获12345678910111213141516171819p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err)&#125;).then(res=&gt;&#123; throw new Error(&apos;happend error&apos;)&#125;).then(res=&gt;&#123; console.log(&apos;third then success&apos;+res)&#125;).catch(err=&gt;&#123; console.log(&apos;catched &apos;+err)&#125;) 控制台会输出：error: errorcatched Error: happend error 如果在catch方法的前面then中有对上一步错误的处理办法会怎么样呢？12345678910111213141516171819202122p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; // resolve(&apos;second resolve: &apos;+res) setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err)&#125;).then(res=&gt;&#123; throw new Error(&apos;happend error&apos;)&#125;).then(res=&gt;&#123; console.log(&apos;third then success&apos;+res)&#125;,err=&gt;&#123; console.log(&apos;third then error &apos;+ err)&#125;).catch(err=&gt;&#123; console.log(&apos;catched &apos;+err)&#125;) 控制台会输出：error: errorthird then error Error: happend error这说明catch捕获，如果catch前面有error处理函数，catch不会捕获异常的。 如果在catch后面继续then呢？1234567891011121314151617181920212223p.then(res=&gt;&#123; return res;&#125;).then(res=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; // resolve(&apos;second resolve: &apos;+res) setTimeout(()=&gt;&#123; reject(&apos;error&apos;) &#125;,2000) &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;,err=&gt;&#123; console.log(&apos;error: &apos;+err)&#125;).then(res=&gt;&#123; throw new Error(&apos;happend error&apos;)&#125;).then(res=&gt;&#123; console.log(&apos;third then success&apos;+res)&#125;).catch(err=&gt;&#123; console.log(&apos;catched &apos;+err) return &apos;catched error&apos;&#125;).then(res=&gt;&#123; console.log(&apos;catched then &apos;+res)&#125;) 控制台会输出：error: errorcatched Error: happend errorcatched then catched error这说明catch后面是可以继续调用then的，catch 在promise的源码里面其实也是一个then，catch遵循then的运行规则。 总结promise链式调用，具体是失败还是成功，取决于以下情况： 成功的条件 then return 一个普通的js 值 then return 一个新的promise成功态的结果 resolve处理失败的条件 then return 一个新的promise失败态的原因 error then throw抛出异常 以上就是promise链式调用的一些实践总结，复习复习基础知识。欢迎大家交流。 参考资料： promise+规范]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+koa2搭建mock数据环境]]></title>
    <url>%2F2020%2F05%2F17%2Fvue-koa2-mock-demo%2F</url>
    <content type="text"><![CDATA[前段时间写了一篇前端vue项目实现mock数据方式的文章，主要是在vue项目里使用mock数据，数据和项目耦合在一起，不太优雅，作为一个有追求的前端，怎么能容忍这种方法呢？特以此篇，记录利用koa2搭建服务端，提供mock数据的方法。 初始化vue项目这里以vue项目为主，当然别的类型项目依然可以使用这种mock数据的方式。 1vue create vue-koa2-demo 前提是安装了vue-cli的脚手架，我电脑安装的是vue-cli3的版本。按照要求一步一步选择后，记得选择安装vuex，后续要使用，启动项目。 koa2项目初始化前端项目弄好之后，开始安装koa 123mkdir koa-democd koa-demonpm koa koa-router koa-cors 安装工作完成后，在项目根目录下新建一个server.js. 12345678910111213141516171819202122let Koa=require(&apos;koa&apos;)let Router=require(&apos;koa-router&apos;)let cors=require(&apos;koa-cors&apos;)let fs=require(&apos;fs&apos;)const app=new Koa()const router=new Router()router.get(&apos;/getData&apos;,async ctx=&gt;&#123; // 允许cors跨域请求 await cors(); // 返回数据 ctx.body=JSON.parse(fs.readFileSync(&apos;./static/data.json&apos;));&#125;)// 将koa和中间件连起来app.use(router.routes()).use(router.allowedMethods());let port=3000;app.listen(port,()=&gt;&#123; console.log(&apos;server is running on&apos;+port)&#125;) 上面请求了一个data.json。需要在项目根目录下新建文件夹static，新建data.json 1234567891011121314151617[&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;曹操&quot;, &quot;age&quot;: &quot;18&quot;&#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;孙权&quot;, &quot;age&quot;: &quot;20&quot;&#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;刘备&quot;, &quot;age&quot;: &quot;24&quot;&#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;魏延&quot;, &quot;age&quot;: &quot;28&quot;&#125;] 在终端中执行命令启动koa项目 1node server.js 当看到下图时，表示启动项目成功 改造前端项目 修改Home.vue文件 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;p&gt;姓名:&#123;&#123; item.name &#125;&#125;&lt;/p&gt; &lt;p&gt;年龄:&#123;&#123; item.age &#125;&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Home&quot;, computed: &#123; list() &#123; return this.$store.state.list; &#125; &#125;, mounted() &#123; this.getlist(); &#125;, methods: &#123; getlist() &#123; this.$store.dispatch(&apos;getData&apos;) &#125; &#125;&#125;;&lt;/script&gt; 修改App.vue文件 12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt; 修改store/index.js123456789101112131415161718192021222324252627282930313233343536import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;import axios from &quot;axios&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; list: [] &#125;, mutations: &#123; setlist(state, data) &#123; state.list = data; &#125; &#125;, actions: &#123; getData(&#123; commit &#125;) &#123; axios .get(&quot;/api/getData&quot;, &#123; headers: &#123; Accept: &quot;application/json&quot;, &quot;Content-Type&quot;: &quot;application/json&quot; &#125; &#125;) .then(res =&gt; &#123; if (res.status === 200) &#123; return res.data; &#125; &#125;) .then(res =&gt; &#123; commit(&quot;setlist&quot;, Array.from(res)); &#125;); &#125; &#125;, modules: &#123;&#125;&#125;); 记得提前安装axios，这里需要使用axios请求后端接口。 新建配置文件在根目录下新建一个vue.config.js，由于前后端项目存在跨域，需要使用代理实现。 12345678910111213141516module.exports = &#123; devServer: &#123; port: 8085, // 端口号 https: false, // https:&#123;type:Boolean&#125; open: true, //配置自动启动浏览器 proxy: &#123; &quot;/api&quot;: &#123; target: &quot;http://127.0.0.1:3000&quot;, changeOrigin: true, pathRewrite: &#123; &quot;^/api&quot;: &quot;/&quot; &#125; &#125; &#125; &#125;&#125;; 重新启动项目1npm run serve 就会看到页面上显示出了koa-demo项目里定义的json数据了，大功告成。 这样以后就可以将mock数据的项目和具体前端项目分离开，更方便的使用。再也不用求着后端给mock数据了，自己搞！ 参考资料 koa官网]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端vue项目实现mock数据方式]]></title>
    <url>%2F2020%2F05%2F05%2Fvue-mock-demo%2F</url>
    <content type="text"><![CDATA[前后端分离开发已成大势所趋，基本上大部分公司的开发模式都是如此，那如何自己本地实现一个数据mock呢？当然你也可以使用在线的工具，比如easymock也可以实现mock数据，但是如果追求稳定性，还是本地搭一套环境吧。下面我介绍的是使用了vue-cli本身自带的功能实现mock 数据。 初始化项目（1）使用vue-cli初始化 1vue create mock-demo 全部采用默认即可 （2）创建配置文件 在项目根目录下创建vue.config.js配置文件。内容如下： 123456789101112131415161718192021222324252627const bodyParser = require("body-parser");const isProduction = process.env.NODE_ENV === "production";let feMock;if (!isProduction) &#123; feMock = require("./mockApi");&#125;module.exports = &#123; publicPath: isProduction ? "././" : "", pages: &#123; index: &#123; entry: "src/main.js", template: "public/index.html", filename: "index.html" &#125; &#125;, devServer: &#123; before: app =&gt; &#123; // 关键代码 app.use(bodyParser.json()); app.use(bodyParser.urlencoded(&#123; extended: true &#125;)); if (!isProduction) &#123; feMock(app); &#125; &#125; &#125;&#125;; 这里主要是利用了webpack-dev-server实现的mock功能，为了实现接口请求，当然需要提前安装axios，body-parser。 1npm i axios body-parser -S 编写mock的API（1）在项目根目录新建文件夹mockApi，新建index.js 12345678const feMock = app =&gt; &#123; app.get("/mock/api/news", function(req, res) &#123; res.json(&#123; name: "tom" &#125;); &#125;);&#125;;module.exports=feMock; （2）在src目录下新建一个api文件夹，新建文件index.js 12345678const prefix = "/mock";export default &#123; methods: &#123; _testMock() &#123; return this.$http.get(`$&#123;prefix&#125;/api/news`); &#125; &#125;&#125;; 这里的请求路径一定要和上一步mock数据的路径保持一致。等后端写好接口之后，统一修改此文件里的prefix接口即可。 组件使用（1）在App.vue里使用 1234567891011121314151617181920212223&lt;script&gt;import api from &quot;./api&quot;;export default &#123; name: &quot;App&quot;, mixins: [api], mounted() &#123; this.testMock(); this.testMock1(); this.testPostMock(); &#125;, methods: &#123; testMock() &#123; this._testMock() .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); &#125; &#125;&#125;;&lt;/script&gt; 正常启动项目后，在浏览器network里就可以看到请求了，初始功能实现。 优化（1）如果项目中多个人写多个mock文件怎么整呢？ （2）能不能直接扫描特定目录加载mock文件呢？是否可以有一个统一的对外入口，每个人只需要写自己的mock文件，不用修改出口？ 解决办法（1）在mockApi文件夹下新建一个mockList文件夹，之后所有人的mock接口写在这里。示例如下： 在mockList中新建一个test.js 123456789101112131415161718192021function testMock(app) &#123; app.get("/mock/api/news", function(req, res) &#123; res.json(&#123; name: "tom" &#125;); &#125;);&#125;function testPostMock(app) &#123; app.post("/mock/api/news", function(req, res) &#123; console.log(req.body); setTimeout(function() &#123; res.json(&#123; code: 0, data: "success", desc: "" &#125;); &#125;, 500); &#125;);&#125;module.exports = [testMock, testPostMock]; 在mockList中新建一个test1.js 12345678function testMock1(app) &#123; app.get("/mock/api/news1", function(req, res) &#123; res.json(&#123; name: "jack" &#125;); &#125;);&#125;module.exports = [testMock1]; (2)修改mockApi/index.js文件 12345678910111213141516const fs = require("fs");const path = __dirname;const files = fs.readdirSync(path + "/mockList");const mockList = [];files.forEach(function(filename) &#123; let model = require(path + "/mockList/" + filename); mockList.push(...model);&#125;);function handleMock(app) &#123; mockList.forEach(func =&gt; &#123; func(app); &#125;);&#125;module.exports = handleMock; 引入fs,自动读取设定目录下的文件，这样配置好之后，其他人只管写自己的mock接口，不需要去修改这个对外的文件，这样就完美解决了。 示例代码目录结构如下：]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索webpack构建速度提升方法和优化策略]]></title>
    <url>%2F2020%2F03%2F08%2Flearnwebpack3%2F</url>
    <content type="text"><![CDATA[一、使用webpack内置得stats分析相关文件stats: 构建的统计信息，package.json 中使用 stats，方式如下： 123&quot;scripts&quot;:&#123; &quot;build:stats&quot;: &quot;webpack --env production --json &gt; stats.json&quot;&#125; 如果你是vue-cli3搭建的项目工程，也可以按照下面得方式使用： 123&quot;scripts&quot;:&#123; &quot;build:stats&quot;: &quot;vue-cli-service build --mode prod --json &gt; stats.json&quot;&#125; 配置好之后，运行命令，就会在根目录生成一个stats.json文件，可以查看分析结果。这种方式只是初级分析，颗粒度较大。 二、使用speed-measure-webpack-plugin进行速度分析1234567891011121314// 安装npm install --save-dev speed-measure-webpack-plugin// 使用方式const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;); const smp = new SpeedMeasurePlugin(); const webpackConfig = smp.wrap(&#123; plugins: [ new MyPlugin(), new MyOtherPlugin() ]&#125;); 配置好之后，运行打包命令的时候就可以看到每个loader 和插件执行耗时。参考：https://www.npmjs.com/package/speed-measure-webpack-plugin 三、使用webpack-bundle-analyzer进行体积分析这个插件应该大部分前端小伙伴都使用过吧！ 1234567891011// 安装npm install --save-dev webpack-bundle-analyzer// 使用const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin; module.exports = &#123; plugins: [ new BundleAnalyzerPlugin() ]&#125; 构建完成后，会在. http://127.0.0.1:8888 展示相关文件大小。按照提示就可以分析依赖的第三方模块文件大小和业务里面的组件代码大小。 四、使用多进程、多实例构建采用这种方式对资源进行并行解析，有如下几种方案： thread-loader(官方推荐)原理：每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中。 12345678910111213141516171819// 使用方式module.exports=&#123; ... module:&#123; rules:[ &#123; test:/\.js$/, use:[&#123; loader:&apos;thread-loader&apos;, options:&#123; workers: 3 &#125; &#125;, &apos;babel-loader&apos; ] &#125;] &#125; ...&#125; parallel-webpack原理：parallel-webpack允许您并行运行多个Webpack构建，从而将工作分散到各个处理器上，从而有助于显着加快构建速度。参考：https://www.npmjs.com/package/parallel-webpack HappyPack原理：每次 webapck 解析一个模块时，HappyPack 会将它及它的依赖分配到worker线程中。提示：由于HappyPack 对file-loader、url-loader 支持的不友好，所以不建议对该loader使用。运行机制如下图所示： 1234567891011121314151617181920// 安装npm install --save-dev happypack// 使用const HappyPack=require(&apos;happypack&apos;)module.exports = &#123; plugins:[ new HappyPack(&#123; id: &apos;jsx&apos;, threads: 4, loaders: [ &apos;babel-loader&apos; ] &#125;), new HappyPack(&#123; id: &apos;styles&apos;, threads: 2, loaders: [ &apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos; ] &#125;) ]&#125; 参考：https://www.npmjs.com/package/happypack如果你使用vue-cli3构建项目的话，自动就会开启多线程打包。 五、多进程并行压缩代码方法一：使用webpack-parallel-uglify-plugin插件 1234567891011121314151617181920212223242526272829const parallelUglifyPlugin=require(&apos;webpack-parallel-uglify-plugin&apos;);module.exports = &#123; plugins: [ new parallelUglifyPlugin(&#123; // Optional regex, or array of regex to match file against. Only matching files get minified. // Defaults to /.js$/, any file ending in .js. test, include, // Optional regex, or array of regex to include in minification. Only matching files get minified. exclude, // Optional regex, or array of regex to exclude from minification. Matching files are not minified. cacheDir, // Optional absolute path to use as a cache. If not provided, caching will not be used. workerCount, // Optional int. Number of workers to run uglify. Defaults to num of cpus - 1 or asset count (whichever is smaller) sourceMap, // Optional Boolean. This slows down the compilation. Defaults to false. uglifyJS: &#123; // These pass straight through to uglify-js@3. // Cannot be used with uglifyES. // Defaults to &#123;&#125; if not neither uglifyJS or uglifyES are provided. // You should use this option if you need to ensure es5 support. uglify-js will produce an error message // if it comes across any es6 code that it can&apos;t parse. &#125;, uglifyES: &#123; // These pass straight through to uglify-es. // Cannot be used with uglifyJS. // uglify-es is a version of uglify that understands newer es6 syntax. You should use this option if the // files that you&apos;re minifying do not need to run in older browsers/versions of node. &#125; &#125;), ],&#125;; 方法二：使用uglify-webpack-plugin插件，开启parallel参数（备注：之前webpack版本使用，不支持压缩ES6的语法） 1234567const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;); module.exports = &#123; optimization: &#123; minimizer: [new UglifyJsPlugin()], &#125;,&#125;; 方法三：使用terser-webpack-plugin插件,开启parallel参数（推荐使用，支持压缩ES6的语法） 123456789101112131415// 安装terset-webpack-pluginnpm install terser-webpack-plugin --save-dev// 使用方式：// webpack.config.jsconst TerserPlugin = require(&apos;terser-webpack-plugin&apos;); module.exports = &#123; optimization: minimize: true, minimizer: [ new TerserPlugin(&#123; parallel: true &#125;) ]&#125;; 六、采用分包方式预编译资源模块可以将vue、vuex、vue-router基础包和业务基础包打包成一个文件。方法：使用DLLPlugin进行分包，DllReferencePlugin对manifest.json引用。第一步：使用DLLPlugin进行分包,创建一个webpack.dll.js 12345678910111213141516171819const path=require(&quot;path&quot;);const webpack=require(&quot;webpack&quot;);module.exports = &#123; entry:&#123; library:[&apos;vue&apos;,&apos;vuex&apos;,&apos;vue-router&apos;] &#125;, output:&#123; filename:&apos;[name]_[chunkhash].dll.js&apos;, path:path.resolve(__dirname,&apos;./build/library&apos;), library:&apos;[name]&apos; &#125;, plugins: [ new webpack.DllPlugin(&#123; name: &apos;[name]_[hash]&apos;, path: resolve(__dirname,&apos;./build/library/[name].json&apos;) &#125;) ]&#125; 第二步：在package.json中增加配置： 123&quot;scripts&quot;: &#123; &quot;dll&quot;: &quot;webpack --config webpack.dll.js&quot; &#125; 运行这条命令，就会生成一个分出的基础包。第三步：在webpack配置文件中增加一个在生产环境起作用的插件配置 1234567module.exports=&#123; plugins:[ new webpack.DllReferencePlugin(&#123; manifest: require(&apos;./build/library/library.json&apos;) &#125;), ]&#125; 七、利用缓存提升二次构建速度方法：（1）babel-loader开启缓存（2）terset-webpack-plugin开启缓存 (webpack4推荐)（3）使用cache-loader 或者hard-source-webpack-plugin 八、缩小构建目标方法一：比如babel-loaader不去解析node_modules 1234567891011module.exports=&#123; module:&#123; rules:[ &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, exclude: &apos;node_modules&apos; &#125; ] &#125;&#125; 方法二：减少文件搜索范围（1）优化 resolve.modules配置(减少模块搜索层级)（2）优化 resolve.mainFields 配置（3）优化 resolve.extensions 配置（4）合理使用 alias 九、使用tree-shaking1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉。 使用:webpack 默认支持，在 .babelrc 里设置 modules: false 即可。production mode的情况下默认开启 要求:必须是 ES6 的语法，CJS 的方式不支持 在webpack构建过程中移除无用的css代码方式。使用purgecss-webpack-plugin，配合mini-css-extract-plugin。 123456789101112131415161718192021222324252627282930const glob = require(&apos;glob&apos;);const path = require(&apos;path&apos;);const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);const PurgecssPlugin = require(&apos;purgecss-webpack-plugin&apos;);const PATHS = &#123; src: path.join(__dirname, &apos;src&apos;)&#125;;module.exports=&#123; module:&#123; rules:[ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos; ] &#125;, ] &#125;, plugins:[ new MiniCssExtractPlugin(&#123; filename: &apos;[name]_[contenthash:8].css&apos; &#125;), new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;PATHS.src&#125;/**/*`, &#123; nodir: true &#125;), &#125;) ]&#125; 十、对图片资源的压缩在引入图片前可以使用某些在线图片压缩网站进行压缩，也可以在webpack中使用工具进行压缩。这里我们使用一个image-webpack-loader来压缩图片。 123456789101112131415161718// 安装npm install image-webpack-loader --save-dev// 使用module.exports=&#123; rules: [&#123; test: /\.(gif|png|jpe?g|svg)$/i, use: [ &apos;file-loader&apos;, &#123; loader: &apos;image-webpack-loader&apos;, options: &#123; disable: true &#125;, &#125;, ], &#125;]&#125; 最后尽可能的使用高版本的webpack和Node,由于版本优化，内置了许多功能，也可以优化webpack的打包速度。 另外在使用vue-cli3构建项目的过程中，vue-cli3本身其实也做了很多优化，上面的优化手段vue-cli3这个工具其实已经帮我们做过了，我们就不用重复配置了，具体想了解的话可以看一下vue-cli3配置的源码 以上就是在学习优化webpack打包过程中的一些学习笔记，特此记录，欢迎小伙伴交流学习！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假期无聊，不如写写简单版React]]></title>
    <url>%2F2020%2F01%2F29%2Flearnreact1%2F</url>
    <content type="text"><![CDATA[各位小伙伴，春节假期已过大半，这个春节应该是历年来过的最安静的一个春节了吧，天天家里蹲，吃了睡，睡了吃，没想到不出门竟然成了对社会最大的贡献。废话不多说，开始说正题。 相信很多人都用过react开发项目，也有很多人好奇页面中明明没有直接用到React，但是页面却必须引入React，否则就会报错。初学者一定有这个疑问，不要着急，今天我就为你解答这个疑问。 JSXjsx是个啥？jsx其实就是个语法糖，用写html的方式来写js，一个很像xml的js扩展。React使用jsx来替代常规的js。在线体验 为什么要引入jsx？写js不香吗？为什么要引入一个新概念jsx来迷惑大家？概括来讲jsx来讲有以下几个好处： 提升开发效率。使用jsx来写模版速度嗖嗖的。 提升执行效率。jsx编译为js代码后进行来很多优化，执⾏更快。 类型安全。在编译过程中就能发现错误。 尝试过上面的在线体验后，就会发现实际上babel-loader会把jsx预编译为React.createElement(xxx)。jsx预处理前： jsx预处理后 通过以上两张图片对比可以解答文章开头的疑问，为什么React没有使用，却必须引入？其实并不是没有使用，只不过没有直接使用，需要经过babel转化。另外可以看出React几个核心API：React.createElement, React.Component, ReactDom.render。 接下来我们就自己动手来实现这三个API吧！ 核心API实现（简版）createElement和Component作用：将传入的节点转化成vdom。（1）创建./simple-react/component.js。实现class组件必备条件。 1234567export class Component&#123; static isReactComponent=&#123;&#125;; constructor(props)&#123; this.props=props; this.state=&#123;&#125; &#125;&#125; （2）创建./simple-react/index.js文件 123456789101112131415161718192021222324252627import &#123;Component&#125; from &quot;./component&quot;function createElement(type,props,...children)&#123; props.children=children; // console.log(type); // 判断组件类型 let vtype; if(typeof type===&quot;string&quot;)&#123; // 原生标签 vtype=1; &#125;else if(typeof type === &quot;function&quot;)&#123; // 类组件，函数式组件 vtype=type.isReactComponent ? 3 : 2; &#125; return &#123; vtype, type, props &#125;&#125;const React=&#123; createElement, Component&#125;export default React; 上面我只是简单使用了1、2、3来分别标示来标签类型，你也可以使用别的方式来处理。createElement被调用时会传入标签类型type，标签属性props及若⼲子元素children。 render作用：渲染vdom，挂载到真实dom树上。创建./simple-react/ReactDOM.js文件，包含render函数。 1234567891011function render(vnode,container)&#123; // vnode-&gt;node mount(vnode,container); // 待实现&#125;const ReactDOM=&#123; render&#125;export default ReactDOM; 这样就实现了代码中的常见的ReactDOM.render(jsx,container)。接下来重点实现mount函数来处理vnode挂载。创建./simple-react/virtual-dom.js文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function mount(vnode,container)&#123; const &#123;vtype&#125;=vnode; if(!vtype)&#123; // 纯文本节点 mountText(vnode,container); &#125; if(vtype===1)&#123; // 原生节点 mountHtml(vnode,container); &#125; if(vtype===2)&#123; // 创建函数式节点 mountFunc(vnode,container) &#125; if(vtype===3)&#123; // 创建class类型组件 mountClass(vnode,container); &#125;&#125;function mountText(vnode,container)&#123; let textNode=document.createTextNode(vnode); container.appendChild(textNode)&#125;function mountHtml(vnode,container)&#123; const &#123;type,props&#125;=vnode; let htmlNode=document.createElement(type); const &#123;children,...rest&#125;=props; Object.keys(rest).map(item=&gt; &#123; if(item===&quot;className&quot;)&#123; htmlNode.setAttribute(&quot;class&quot;,rest[item]); &#125; if(item.slice(0,2)===&quot;on&quot;)&#123; // 简单处理click事件，实际情况很复杂，需要考虑多种情况 htmlNode.addEventListener(&quot;click&quot;,rest[item]) &#125; &#125;) children.map(item=&gt;&#123; if(Array.isArray(item))&#123; item.map(i=&gt;mount(i,htmlNode)) &#125;else&#123; mount(item,htmlNode) &#125; &#125;) container.appendChild(htmlNode)&#125;function mountFunc(vnode,container)&#123; const &#123;type,props&#125;=vnode; let node=type(props); mount(node,container);&#125;function mountClass(vnode,container)&#123; const &#123;type,props&#125;=vnode; let cmp=new type(props); let node=cmp.render(); mount(node,container);&#125; mount函数创建好之后，完整的ReactDOM文件就可以改写为如下： 12345678910111213import &#123;mount&#125; from &quot;./virtual-dom&quot;;function render(vnode,container)&#123; // vnode-&gt;node mount(vnode,container)&#125;const ReactDOM=&#123; render&#125;export default ReactDOM; 相关文件创建好之后，在由creat-react-app创建好的项目中改写index.js文件，引入自己写好的简版react文件，进行测试。 123456789101112131415161718192021222324252627282930313233343536373839404142import React from &quot;./simple-react&quot;;import ReactDOM from &quot;./simple-react/ReactDOM&quot;;import &apos;./index.css&apos;function Funcomp(props)&#123; return ( &lt;div className=&quot;border&quot;&gt;&#123;props.name&#125;&lt;/div&gt; )&#125;class ClassComp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125; &#125; handleClick=()=&gt;&#123; alert(&quot;hello&quot;) &#125; render() &#123; return ( &lt;div className=&quot;border&quot;&gt; &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; &#123; [1,2,3].map(item=&gt; ( &lt;h1 key=&#123;item&#125;&gt;&#123;item&#125;&lt;/h1&gt; ) ) &#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;let jsx=( &lt;div&gt; &lt;div className=&quot;border&quot;&gt;我是内容&lt;/div&gt; &lt;Funcomp name=&quot;我是函数组件内容&quot; /&gt; &lt;ClassComp name=&quot;我是class组件内容&quot; /&gt; &lt;/div&gt;)ReactDOM.render(jsx,document.getElementById(&quot;root&quot;)) 实际页面效果如果和下面截图一样，代表着简版react大功告成。 总结 webpack+babel编译时，替换jsx为React.createElement(type,props,…children)。 所有React.createElement()执⾏结束后得到⼀个JS对象即vdom，一个能够完整描述dom结构的对象。 ReactDOM.render(vdom,container)可以将vdom转换为真实dom并添加container中。 当然在实际react处理中，要处理的情况远比上面写的复杂多得多，dom的更新、替换、删除要经过diff的过程，打补丁，更新布丁等过程，v16.8之后的fiber更是类似于时间分片的方式，将任务拆分，将高优先级任务优先执行，提高页面渲染的流畅度等等，有很多需要我们掌握的东西。 应了那句话：路漫漫其修远兮，吾将上下而求索。 欢迎点赞、留言、交流。 参考资料 React中文网 React源码]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过bundler学习webpack模块依赖分析]]></title>
    <url>%2F2019%2F12%2F22%2Flearnwebpack2%2F</url>
    <content type="text"><![CDATA[你知道webpack是如何分析模块各个依赖关系的？是如何将ES6代码编译成浏览器可执行代码的吗？ 项目初始化 创建文件夹 12mkdir bundlercd bundler 创建相关文件在bundler中创建src文件夹，在src文件夹新建index.js,message.js,word.js。文件内容如下： 1234567891011// word.jsexport const word=&quot;word&quot;;// message.jsimport &#123;word&#125; from &quot;./word.js&quot;;const message=`hello $&#123;word&#125;`;export default message;// index.jsimport message from &quot;./message.js&quot;;console.log(message); 如果想直接在浏览器中运行index.js的话，当然是不能的，浏览器无法识别es6的语法，以前我们都是通过类似webpack的打包工具将es6代码转换成es5的代码，然后直接在浏览器中运行。 入口文件依赖分析在项目根目录下新建一个bundler文件，实现打包过程。其实所谓的webpack编译打包就是通过一些特定的方法函数将源代码转换成浏览器可识别的代码 定义一个模块分析函数 1234const moduleAnalyser=(filename)=&gt;&#123;&#125;moduleAnalyser(&quot;./src/index.js&quot;);// 入口函数 读取文件内容这里使用了node中的一个核心模块fs。 1234567const fs=require(&quot;fs&quot;);const moduleAnalyser=(filename)=&gt;&#123; const content=fs.readFileSync(filename,&quot;utf-8&quot;);// 读取文件内容 console.log(content);&#125;moduleAnalyser(&quot;./src/index.js&quot;);// 入口函数 在终端中执行node命令 1node bundler.js 就会输出index.js的文件内容 解析文件依赖 （1）执行npm init -y初始化 （2）安装一个babel模块 1npm install @babel/parser --save （3）使用parser 1234567891011const fs=require(&quot;fs&quot;);const parser=require(&quot;@babel/parser&quot;);const moduleAnalyser=(filename)=&gt;&#123; const content=fs.readFileSync(filename,&quot;utf-8&quot;);// 读取文件内容 console.log(parser.parse(content,&#123; sourceType:&quot;module&quot; &#125;));&#125;moduleAnalyser(&quot;./src/index.js&quot;);// 入口函数 再次执行node命令，node bundler.js，查看文件内容,输出的就是常说的AST,描述了文件的相关依赖关系。 修改一下bundler 123456...const ast=parser.parse(content,&#123; sourceType:&quot;module&quot; &#125;) console.log(ast.program.body);... 执行node bundler.js命令就会得到如下输出内容输出的就是文件相关依赖，type为ImportDeclaration表示是引入声明，type为ExpressionStatement表示是表达式。接下来要做的就是遍历body的内容得到依赖关系。（4）安装模块 1npm install @babel/traverse --save （5）使用traverse 1234567...traverse(ast,&#123; ImportDeclaration(&#123;node&#125;)&#123; console.log(node)// 查看node内容 &#125; &#125;)... 继续改写bundler.js 1234567const dependencies=[]; traverse(ast,&#123; ImportDeclaration(&#123;node&#125;)&#123; dependencies.push(node.source.value); &#125; &#125;) console.log(dependencies)// 得到依赖数组 继续改写bundler.js 12345678const dependencies=&#123;&#125;;// 变成对象，key是依赖路径，value是相对依赖路径。便于之后使用 traverse(ast,&#123; ImportDeclaration(&#123;node&#125;)&#123; const dirname=path.dirname(filename);//filename对应的文件夹路径 const newFile=&quot;./&quot;+path.join(dirname,node.source.value); dependencies[node.source.value]=newFile; &#125; &#125;) （6）安装babel/core转换代码 1npm install @babel/core @babel/preset-env --save （7）转换代码 1234const &#123; code &#125;=babel.transformFromAst(ast,null,&#123; presets:[&quot;@babel/preset-env&quot;] &#125;)//转换ast console.log(code); 执行node bundler.js命令就会得到如下输出内容 入口文件的依赖分析就完成了。完整代码如下： 12345678910111213141516171819202122232425262728293031const fs=require(&quot;fs&quot;);const path=require(&quot;path&quot;);const babel=require(&quot;@babel/core&quot;);const parser=require(&quot;@babel/parser&quot;);const traverse=require(&quot;@babel/traverse&quot;).default;// 默认es module导出const moduleAnalyser=(filename)=&gt;&#123; const content=fs.readFileSync(filename,&quot;utf-8&quot;);// 读取文件内容 const ast=parser.parse(content,&#123; sourceType:&quot;module&quot; &#125;) const dependencies=&#123;&#125;; traverse(ast,&#123; ImportDeclaration(&#123;node&#125;)&#123; const dirname=path.dirname(filename);//filename对应的文件夹路径 const newFile=&quot;./&quot;+path.join(dirname,node.source.value); dependencies[node.source.value]=newFile; &#125; &#125;) const &#123; code &#125; = babel.transformFromAst(ast,null,&#123; presets:[&quot;@babel/preset-env&quot;] &#125;)//转换ast return &#123; filename, dependencies, code &#125;&#125;const moduleInfo=moduleAnalyser(&quot;./src/index.js&quot;);// 入口函数console.log(moduleInfo); 构建依赖图谱一个项目不可能只有一个文件，这就需要我们分析整个项目的依赖关系，即生成得到依赖图谱。 定义生成依赖图谱方法 1234const makeDependenciesGraph=(entry)=&gt;&#123; const entryModule=moduleAnalyser(entry); console.log(entryModule);&#125; 从入口开始，循环递归分析依赖关系 123456789101112131415const makeDependenciesGraph=(entry)=&gt;&#123; const entryModule=moduleAnalyser(entry); const graphArray=[entryModule]; for(let i=0;i&lt;graphArray.length;i++)&#123; const item=graphArray[i]; const &#123; dependencies &#125; = item; // 解构出依赖 if(dependencies)&#123; for(let j in dependencies)&#123; // 递归分析依赖,放入依赖图谱数组 graphArray.push(moduleAnalyser(dependencies[j])) &#125; &#125; &#125; console.log(graphArray);&#125; 执行node bundler.js命令就会得到如下输出内容 生成依赖图谱graph对象，完整代码如下： 1234567891011121314151617181920212223const makeDependenciesGraph=(entry)=&gt;&#123; const entryModule=moduleAnalyser(entry); const graphArray=[entryModule]; for(let i=0;i&lt;graphArray.length;i++)&#123; const item=graphArray[i]; const &#123; dependencies &#125; = item; // 解构出依赖 if(dependencies)&#123; for(let j in dependencies)&#123; // 递归分析依赖,放入依赖图谱数组 graphArray.push(moduleAnalyser(dependencies[j])) &#125; &#125; &#125; // 转换为对象 便于使用 const graph=&#123;&#125; graphArray.forEach(item=&gt;&#123; graph[item.filename]=&#123; dependencies:item.dependencies, code:item.code &#125; &#125;); return graph;&#125; 生成浏览器可识别代码123456789101112131415161718const generateCode=(entry)=&gt;&#123; const graph=JSON.stringify(makeDependenciesGraph(entry)); return ` (function(graph)&#123; function require(module)&#123; function localRequire(relativePath)&#123; return require(graph[module].dependencies[relativePath]) &#125; var exports=&#123;&#125;; (function(require,exports,code)&#123; eval(code) &#125;)(localRequire,exports,graph[module].code); return exports; &#125;; require(&apos;$&#123;entry&#125;&apos;); &#125;)($&#123;graph&#125;) `;&#125; 执行node bundler.js命令就会得到如下输出内容将输入内容拷贝后到浏览器console中执行，便会得到代码的正常输出 bundler文件完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const fs=require(&quot;fs&quot;);const path=require(&quot;path&quot;);const babel=require(&quot;@babel/core&quot;);const parser=require(&quot;@babel/parser&quot;);const traverse=require(&quot;@babel/traverse&quot;).default;// 默认es module导出const moduleAnalyser=(filename)=&gt;&#123; const content=fs.readFileSync(filename,&quot;utf-8&quot;);// 读取文件内容 const ast=parser.parse(content,&#123; sourceType:&quot;module&quot; &#125;) const dependencies=&#123;&#125;; traverse(ast,&#123; ImportDeclaration(&#123;node&#125;)&#123; const dirname=path.dirname(filename);//filename对应的文件夹路径 const newFile=&quot;./&quot;+path.join(dirname,node.source.value); dependencies[node.source.value]=newFile; &#125; &#125;) const &#123; code &#125;=babel.transformFromAst(ast,null,&#123; presets:[&quot;@babel/preset-env&quot;] &#125;)//转换ast return &#123; filename, dependencies, code &#125;&#125;const makeDependenciesGraph=(entry)=&gt;&#123; const entryModule=moduleAnalyser(entry); const graphArray=[entryModule]; for(let i=0;i&lt;graphArray.length;i++)&#123; const item=graphArray[i]; const &#123; dependencies &#125; = item; // 解构出依赖 if(dependencies)&#123; for(let j in dependencies)&#123; // 递归分析依赖,放入依赖图谱数组 graphArray.push(moduleAnalyser(dependencies[j])) &#125; &#125; &#125; // 转换为对象 便于使用 const graph=&#123;&#125; graphArray.forEach(item=&gt;&#123; graph[item.filename]=&#123; dependencies:item.dependencies, code:item.code &#125; &#125;); return graph;&#125;const generateCode=(entry)=&gt;&#123; const graph=JSON.stringify(makeDependenciesGraph(entry)); return ` (function(graph)&#123; function require(module)&#123; function localRequire(relativePath)&#123; return require(graph[module].dependencies[relativePath]) &#125; var exports=&#123;&#125;; (function(require,exports,code)&#123; eval(code) &#125;)(localRequire,exports,graph[module].code); return exports; &#125;; require(&apos;$&#123;entry&#125;&apos;); &#125;)($&#123;graph&#125;) `;&#125;const code=generateCode(&quot;./src/index.js&quot;);// 入口函数console.log(code); 以上就是一个webpack代码转换编译的整个过程。继续学习中！ 参考资料 babel中parser模块文档 babel中core模块文档]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用webpack打包一个库library]]></title>
    <url>%2F2019%2F12%2F17%2Flearnwebpack1%2F</url>
    <content type="text"><![CDATA[日常我们开发了一个库之后，如何打包之后提供给别人使用呢？如果你不清楚，就继续看吧！！！ 初始化库123mkdir librarycd librarynpm init -y 经过以上步骤后会生成一个library文件夹，里面包含一个package.json文件。然后简单修改为如下所示： 123456789101112&#123; &quot;name&quot;: &quot;library&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;./dist/library.js&quot;, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;rocky&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 简单创建几个文件在根目录下新建src文件夹，新建一个math.js和string.js。相关文件内容如下： 12345678910111213141516// math.jsexport function add(a,b)&#123; return a+b;&#125;export function minus(a,b)&#123; return a-b;&#125;export function multiply(a,b)&#123; return a*b;&#125;export function division(a,b)&#123; return a/b;&#125; 1234// string.jsexport function join(a,b)&#123; return a+&quot; &quot;+b;&#125; 继续新建一个index.js 1234import * as math from &quot;./math&quot;;import * as string from &quot;./string&quot;;export default &#123;math,string&#125; 简单安装webpack依赖1npm install webpack webpack-cli --save 安装的同时，可以创建webpack配置文件webpack.config.js，如下配置： 123456789101112const path = require(&quot;path&quot;);module.exports=&#123; mode:&quot;production&quot;, entry:&quot;./src/index.js&quot;, output:&#123; path:path.resolve(__dirname,&quot;dist&quot;), filename:&quot;library.js&quot;, library:&quot;library&quot;,// 在全局变量中增加一个library变量 libraryTarget:&quot;umd&quot; &#125;&#125; 安装成功后，执行打包命令 1npm run build 之后会在根目录下生成一个dist文件夹，里面包含一个library.js。 如何使用呢？如果别人要使用这个打包后的library.js的话，可能会有如下几种方式： 1234567891011// es6方式import library from &quot;library&quot;// commonjs方式const library=require(&quot;library&quot;)// AMD方式require([&quot;library&quot;],function()&#123;&#125;)// script标签引入&lt;script src=&quot;library.js&quot;&gt;&lt;/script&gt; 在dist文件夹里创建一个index.html，用script引入之前打包生成的library.js。浏览器打开index.html,在控制台中输入library,会得到如下所示的结果：一个简单的库便打包生成了。注解：webpack中libraryTarget配置项可以设为umd,表示采用umd规范，如果设置为this,表示在this下挂载了一个library变量。更多用法可参考webpack官网。 引入别的库用法假设需要引入lodash.安装lodash 1npm install lodash --save 修改之前创建的string.js 123456import _ from &quot;lodash&quot;;export function join(a,b)&#123; // return a+&quot; &quot;+b; return _.join([a,b],&quot; &quot;);&#125; 运行打包命令，发现打包出来的库体积变大了，因为我们引入了lodash,导致包变大。怎么办呢？修改webpack配置文件。增加一个externals配置项： 12345678910111213const path =require(&quot;path&quot;);module.exports=&#123; mode:&quot;production&quot;, entry:&quot;./src/index.js&quot;, externals:[&quot;lodash&quot;],// 配置不打包文件 output:&#123; path:path.resolve(__dirname,&quot;dist&quot;), filename:&quot;library.js&quot;, library:&quot;library&quot;, libraryTarget:&quot;umd&quot; &#125;&#125; 之后打包就会发现库的体积又变小了。 以上就是一个简单打包库的过程，打包完成后，就可以使用npm相关命令将库发布到npm仓库，发布成功后，就可以让别的小伙伴使用了。当然在实际情况中，打包一个库的话，需要做的还有很多，比如tree-shaking,优化方面的东西，我也正在逐渐学习中！ 参考资料 webpack output libraryTarget webpack external]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目整合Eslint和stylelint规范代码]]></title>
    <url>%2F2019%2F09%2F14%2Fcodelint%2F</url>
    <content type="text"><![CDATA[前言最近在搭建项目框架，想着上一个项目代码风格各异，就想着在新项目中引入Eslint来规范团队成员代码风格，保持统一，也方便大家维护代码，减少不必要的错误。前端应用愈加复杂，代码规范问题必须通过强制的方式保持统一。以下是团队逐渐摸索出的一些配置，各取所需。 Eslint配置在用vue-cli3搭建项目的过程中就会问你是否需要Eslint，选择就好来。如果没有选择后期又想加入eslint，可以手动安装Eslint的相关依赖。 安装1npm install eslint eslint-plugin-vue --save-dev 需要注意：Node.js (&gt;=6.14), npm version 3+。 创建Eslint配置文件在项目根目录下新建一个文件，名.eslintrc.js。下面是个人的一些配置，可以自行参考。 1234567891011121314151617181920212223242526272829module.exports = &#123; root: true, env: &#123; browser: true, node: true, es6: true &#125;, extends: [&quot;eslint:recommended&quot;, &quot;plugin:vue/essential&quot;, &quot;@vue/prettier&quot;], rules: &#123; &quot;generator-star-spacing&quot;: &quot;off&quot;, &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;, &quot;vue/no-parsing-error&quot;: [ 2, &#123; &quot;unexpected-solidus-in-tag&quot;: false &#125; ] &#125;, parserOptions: &#123; parser: &quot;babel-eslint&quot;, ecmaVersion: 7, sourceType: &quot;module&quot;, ecmaFeatures: &#123; // 添加ES特性支持，使之能够识别ES6语法 jsx: true &#125; &#125;&#125;; 忽略Eslint校验如果一些文件不需要Eslint的校验，可以配置一个.eslintignore，里面写上需要排除的文件。 12345/build//config//dist//*.js/test/unit/coverage/ stylelint配置stylelint可以帮助我们规范化css的书写，风格统一，减少错误。 安装依赖1npm i -D stylelint stylelint-config-standard stylelint-webpack-plugin 配置在项目根目录下新建配置文件.stylelintrc.js，相关配置如下： 1234567891011module.exports = &#123; extends: &quot;stylelint-config-standard&quot;, rules: &#123; &quot;color-no-invalid-hex&quot;: true, &quot;rule-empty-line-before&quot;: null, &quot;color-hex-length&quot;: &quot;long&quot;, &quot;color-hex-case&quot;: &quot;lower&quot;, &quot;unit-whitelist&quot;: [&quot;em&quot;, &quot;rem&quot;, &quot;%&quot;, &quot;s&quot;, &quot;px&quot;], &quot;declaration-colon-newline-after&quot;: null &#125;&#125;; 代码美化prettier配置虽然借助 Eslint 来提高代码质量，但是却无法保证代码风格统一。一个统一的代码风格对于团队来说是很有价值的，所以为了达到目的，我们使用了 Prettier在保存和提交代码的时候，将代码修改成统一的风格。 安装依赖1npm i -D prettier @vue/eslint-config-prettier 配置相关配置写在.eslintrc.js中 1extends: [&quot;eslint:recommended&quot;, &quot;plugin:vue/essential&quot;, &quot;@vue/prettier&quot;] 我使用的是vscode编辑器，同时配置了vscode。 12345678910111213141516171819&#123; &quot;eslint.autoFixOnSave&quot;: true, &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &#123; &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true &#125;, &quot;html&quot;, &quot;vue&quot; ], &quot;editor.wordWrap&quot;: &quot;wordWrapColumn&quot;, &quot;editor.formatOnSave&quot;: true, &quot;vetur.validation.template&quot;: false, &quot;cSpell.ignoreWords&quot;: [ &quot;menu&quot;, &quot;mixins&quot; ]&#125; 推荐使用vscode的同学安装eslint和Prettier - Code formatter这两个插件，配合上面的配置，达到保存的时候自动格式化和校验的目的。 提交时校验安装两个工具 husky：一个方便用来处理 pre-commit 、 pre-push 等 githooks 的工具 lint-staged：对 git 暂存区的代码，运行 linters 的工具 1npm i lint-staged husky -D package.json增加配置1234567891011121314...&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot; &#125; &#125;, &quot;lint-staged&quot;: &#123; &quot;src/**/*.&#123;js,jsx,vue&#125;&quot;: [ &quot;prettier --tab-width 2 --write&quot;, &quot;vue-cli-service lint --fix&quot;, &quot;git add&quot; ] &#125;... 这样就可以实现在提交的时候校验，保证错误的代码无法提交。 到目前为止，项目中就整合进了Eslint校验，prettier美化代码，提交hooks代码检查。 参考 Eslint stylelint stylelint指南]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ueditor图片上传方式处理]]></title>
    <url>%2F2019%2F09%2F13%2Fueditorupload%2F</url>
    <content type="text"><![CDATA[最近项目里需要用到富文本编辑器，同事选择里百度出的ueditor，但是里面自带的图片上传功能需要后台配合，配置成服务器地址，和我们实际情况不是太符合，于是另想办法，搞定图片上传。 重写配置项首先重写里toolbars配置。最重要的是要把原先的上传图片功能按钮去掉，下面是我用到的配置项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647toolbars: [ [ &quot;fullscreen&quot;, &quot;source&quot;, &quot;undo&quot;, &quot;redo&quot;, &quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;fontborder&quot;, &quot;strikethrough&quot;, &quot;superscript&quot;, &quot;subscript&quot;, &quot;removeformat&quot;, &quot;formatmatch&quot;, &quot;autotypeset&quot;, &quot;blockquote&quot;, &quot;pasteplain&quot;, &quot;|&quot;, &quot;forecolor&quot;, &quot;backcolor&quot;, &quot;insertorderedlist&quot;, &quot;insertunorderedlist&quot;, &quot;selectall&quot;, &quot;cleardoc&quot;, &quot;mergeright&quot;, //右合并单元格 &quot;mergedown&quot;, //下合并单元格 &quot;deleterow&quot;, //删除行 &quot;deletecol&quot;, //删除列 &quot;splittorows&quot;, //拆分成行 &quot;splittocols&quot;, //拆分成列 &quot;splittocells&quot;, //完全拆分单元格 &quot;deletecaption&quot;, //删除表格标题 &quot;inserttitle&quot;, //插入标题 &quot;mergecells&quot;, //合并多个单元格 &quot;deletetable&quot;, //删除表格 &quot;cleardoc&quot;, //清空文档 &quot;insertparagraphbeforetable&quot;, //&quot;表格前插入行&quot; &quot;fontfamily&quot;, //字体 &quot;fontsize&quot;, //字号 &quot;paragraph&quot;, //段落格式 &quot;inserttable&quot;, //插入表格 &quot;edittable&quot;, //表格属性 &quot;edittd&quot;, //单元格属性 &quot;link&quot; //超链接 ] ] 更多配置可参考官网 添加初始化方法初始化ueditor的时候触发一个方法，因为我的项目是用vue写的，而且封装了一层ueditor,所以就对外暴露了一个beforeInit方法。 123456&lt;fw-ueditor-wrap v-model=&quot;mainBody&quot; :config=&quot;myConfig&quot; @beforeInit=&quot;addCustomDialog&quot; :key=&quot;1&quot;&gt;&lt;/fw-ueditor-wrap&gt; 123456789101112131415161718192021222324// 添加自定义弹窗 addCustomDialog(editorId) &#123; let that = this; window.UE.registerUI( &quot;test-dialog&quot;, function(editor, uiName) &#123; // 参考http://ueditor.baidu.com/doc/#COMMAND.LIST var btn = new window.UE.ui.Button(&#123; name: &quot;dialog-button&quot;, title: &quot;上传图片&quot;, cssRules: `background-image: url(&apos;/image/upload.png&apos;) !important;background-size: cover;`, onclick: function() &#123; // 渲染dialog that.dialogVisible = true; editor.execCommand(uiName); &#125; &#125;); return btn; &#125;, 100 /* 指定添加到工具栏上的那个位置，默认时追加到最后 */, editorId /* 指定这个UI是哪个编辑器实例上的，默认是页面上所有的编辑器都会添加这个按钮 */ ); &#125; 其实就是在toolbar工具栏后面又加了一个自定义的按钮，实现上传功能。 element弹窗设置弹窗我用的是element的弹窗，使用方式参考element官网弹窗。并且使用了element的upload上传组件1234567891011121314151617181920212223242526&lt;el-dialog title=&quot;上传图片&quot; v-if=&quot;dialogVisible&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; &gt; &lt;el-upload class=&quot;upload-demo&quot; drag accept=&quot;.png, .jpg&quot; :headers=&quot;headers&quot; :action=&quot;uploadAddr&quot; :beforeUpload=&quot;beforeAvatarUpload&quot; :on-success=&quot;uploadImageSuccess&quot; :on-error=&quot;uploadImageError&quot; &gt; &lt;i class=&quot;el-icon-upload&quot;&gt;&lt;/i&gt; &lt;div class=&quot;el-upload__text&quot;&gt; 将文件拖到此处，或 &lt;em&gt;点击上传&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;el-upload__tip&quot; slot=&quot;tip&quot;&gt; 只能上传jpg/png文件，且不超过5M &lt;/div&gt; &lt;/el-upload&gt; &lt;/el-dialog&gt; 关键的就是上传成功后需要触发uploadFile方法，将上传成功的图片插入到富文本编辑器中 123456789101112131415161718192021222324252627282930uploadFile(file) &#123;//关键 let editor = document.querySelector(&quot;.edui-default&quot;).getAttribute(&quot;id&quot;); window.UE.getEditor(editor).execCommand(&quot;insertimage&quot;, &#123; src: file.url, width: &quot;100&quot;, height: &quot;100&quot; &#125;); this.dialogVisible = false; &#125;, // eslint-disable-next-line no-unused-vars uploadImageSuccess(response, file, fileList) &#123; if (response) &#123; this.$message(&#123; message: &quot;上传成功&quot;, type: &quot;success&quot; &#125;); let fileObj = &#123; name: response.originalName, url: response.url &#125;; // this.fileList.push(fileObj); this.uploadFile(fileObj); &#125; else &#123; this.$message(&#123; message: &quot;上传失败&quot;, type: &quot;warning&quot; &#125;); &#125; &#125; 大功告成，搞定！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件化思考]]></title>
    <url>%2F2019%2F08%2F24%2FvueCompThinking%2F</url>
    <content type="text"><![CDATA[项目结束一段时间，写个文章总结下。初入项目组，看到了3000行的vue文件，一口血差点捧出，无奈上一个程序员已经离职，留下的坑，只能自己填上了。在重构项目的过程中，也发现了一些别的问题，组内分享会做了总结分享，这次总结成文章特此记录。 用搭积木的方式构建vue组件，就如同搭积木一样，构建我们的项目 在项目中，对于组件的划分，我们一般会划分为业务组件和功能组件，也可以称为视图组件和容器组件。在react中也被称为无状态组件和UI组件。组件划分明确，对于代码的可维护性和阅读性有一定的便利性。划分方式如下图所示： 组件设计考量，分而治之天下大事，分久必合，合久必分。组件亦然，由以前的写在一起，到如今的明确划分。分而治之的思想，也可以让我们更加专注于主要的功能实现，便于扩展和复用。在组件的设计中，需要考虑以下几点： 可扩展性强扩展性首先是我们要考虑的点，如果不能扩展，就代表着代码写死，失去了代码的灵活性 组件中方法函数的抽离，便于复用，适用程度高。尽可能使用方法定义，避免使用template表达式，不便于复用 文档清楚详细毕竟写的组件是给人用的，不完善的文档让别人如何使用，肯定不能手把手教别人怎么使用吧，所以一个组件详细的使用说明是必须的。 颗粒度合适，适度抽象这个是一个经验的问题，如何衡量颗粒度是否合适，其实是一个度的问题，每个人有每个人的看法，但是尽量保证一个组件完成的功能是单一的，而不是多个功能的结合体。 功能尽可能单一，代码行数适中这一点和上面颗粒度类似，以代码行数衡量也可以，一般的组件如果抽离合适的话，绝对不会超过1000行，如果代码太多，就说明组件划分不合理，抽离不完善，需要重新设计。 必要的时候需要ui的配合（设计不止于好看，更关乎好用。—乔布斯）有的组件设计出来太丑，程序员的眼光和一个专业的设计师的眼光还是有一定差距的，所以如果可以的话可以请专业的设计师设计以下ui界面，在一定程度上可以吸引到别人。 组件设计参考点组件间props原子化父子组件通过 props 属性传值时，尽可能的规定数据类型并且使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数。尽量避免复杂的对象。 有以下几点注意： 保证组件API清晰直观 更好的理解每一个prop的含义和作用 传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被自定义组件使用，这使得代码难以重构和维护。 保证组件可用（防御性编程） 示例： 巧妙利用slot扩展组件用好slot可以设计出很多优秀的组件。 合理使用mixin实现复用Mixins封装可重用的代码，避免重复。如果多个组件共享相同功能，则可以使用mixin。通过mixin，可以专注于单个组件的任务和抽象的通用代码。这有助于更好地维护应用程序。 及时模块化在决定抽离成组件之前，先问一下自己下面几个问题： 是否有足够的页面结构/逻辑来保证它？ 代码重复（或可能重复）？ 它会减少需要书写的模板吗？ 性能会收到影响吗？ 你是否会在测试代码的所有部分时遇到问题？ 你是否有一个明确的理由？ 这些好处是否超过了成本？当你明确了上面几个问题后，是否抽离组件相信你已经有了明确的答案。 如何设计组件？何时抽离组件？如何抽离一个合适的组件？都是一些设计原则加上实际经验相互作用下作出的判断，理论指导，实践判断。 最后用一段鸡汤文结尾： 在一天结束时，虽然你的直接责任可能是“编写代码”，但你不应忽视你的最终目标，即建立一些东西。创建产品。为了产生一些你可以引以为豪的东西并帮助别人，即使它在技术上并不完美，永远记得找到一个平衡点。不幸的是，在一周内每天 8 小时盯着眼前的代码会使得眼界和角度变得更为“狭窄”，这个时候你需要的你是退后一步，确保你不要为了一颗树而失去整个森林。 感谢各位大佬的阅读，谢谢！🙏🙏🙏]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React构建精简版本掘金（五）]]></title>
    <url>%2F2019%2F04%2F30%2Freact-juejin5%2F</url>
    <content type="text"><![CDATA[距离上篇文章已经过去了大半个月，本来打算只更新代码，最后还是决定把做的过程中遇到的问题记录出来，说不定就可以帮助一些同学，也算是幸事，如果没有，那就当作自己梳理知识点吧！ 该篇文章主要讲述以下知识点： 如何mock数据 React组件中修改Redux中的数据 mock数据有三种方式： 利用node搭服务，mock数据 利用现成网上mock服务，比如easy mock 本地json数据模拟请求 介绍下本地数据模拟请求，利用axios请求数据： 12345678910111213141516import axios from &apos;axios&apos;;const BaseUrl=&apos;./mock/homeData/&apos;;const getHome=()=&gt;&#123; return axios.get(BaseUrl+&apos;home.json&apos;).then(res=&gt;&#123; return res.data &#125;)&#125;const getArticleList=()=&gt;&#123; return axios.get(BaseUrl+&apos;articleList.json&apos;).then(res=&gt;&#123; return res.data &#125;)&#125;export &#123; getHome,getArticleList &#125; 本地json数据存放位置如下 React组件中修改Redux中的数据定义好state，reducer12345678910111213141516171819202122232425262728293031323334353637//userReducer.js// 1.定义默认数据let initialState = &#123; userId:&apos;&apos;, userName:&apos;&apos;,//实际项目与此不同 userImage: &apos;&apos;, userDesc:&apos;&apos;&#125;// action creatorsexport const actions = &#123; login: (userInfo) =&gt; &#123; return &#123;type: &apos;CHANGE_USER&apos;,userName: userInfo.username,userId:userInfo.userId&#125; &#125;, logout:()=&gt;&#123; return &#123;type:&apos;LOGOUT&apos;&#125; &#125;&#125;;// 2.Reducerconst userReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case &apos;CHANGE_USERIMAGE&apos;: return &#123; ...state, userImage: action.userImage &#125; case &apos;CHANGE_USERID&apos;: return &#123; ...state,userId:action.userId&#125; case &apos;CHANGE_USER&apos;: return &#123; ...state,userName:action.userName,userId:action.userId&#125; case &apos;LOGOUT&apos;: return &#123;...state,userName:&apos;&apos;,userId:&apos;&apos;&#125; default: return state &#125;&#125;// 3.导出export default userReducer; 在组件中操作修改state 1234567891011121314151617...this.props.login(&#123;username:username,userId:userId&#125;);//修改存储在redux中的用户信息...const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return bindActionCreators(&#123; login: authActions.login &#125;,dispatch);&#125;Login=connect(mapStateToProps,mapDispatchToProps)(Login)export default Login; Redux通过reducer解析action。reducer是一个普通的js函数，接受action作为参数，然后返回一个新的state。 三大原则 唯一数据源 保持state状态只读 state的改变必须通过纯函数完成 ReduxRedux应用只维护一个全局的状态对象，存在Redux的store中。程序任何时候都不能直接去修改状态state，如果需要修改state，必须发送一个action，通过action去描述如何修改state。action描述了改变state的意图，真正对state作出修改的是reducer。reducer必须是纯函数，所以reducer在收到action后，不能直接去修改原来的状态state，而是应该创建一个新的状态对象返回。 纯函数需要满足两个条件：（1）对于同样的参数值，函数返回结果总是相同的，就是函数结果不依赖任何在程序执行过程中可能改变的变量。（2）函数的执行过程不会产生比的副作用，例如会修改外部对象，有时会去修改页面标题，这就是副作用。 数据流向的一个简单示意图，来自Flux官网 可以看出Redux应用的主要组成有action，reducer和store。 actionaction是Redux中的信息载体，是store的唯一来源。把action发给store必须通过store中的dispach方法。其实action就是一个普通的js对象，但是每个action必须有一个type属性用来描述action类型，要做什么操作。除了type属性歪，action的结构完全由你决定，不过应该保证可以清晰描述使用场景。 123456function logout(info)&#123; return &#123; type:&apos;LOGOUT&apos;, info &#125;&#125; reducerreducer根据action做出响应，决定如何修改应用状态state。其实在写reducer之前就应该设计好state。 state：1234567// 1.定义默认数据let initialState = &#123; userId:&apos;&apos;, userName:&apos;&apos;,//实际项目与此不同 userImage: &apos;&apos;, userDesc:&apos;&apos;&#125; reducer： 123456789101112131415// 2.Reducerconst userReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case &apos;CHANGE_USERIMAGE&apos;: return &#123; ...state, userImage: action.userImage &#125; case &apos;CHANGE_USERID&apos;: return &#123; ...state,userId:action.userId&#125; case &apos;CHANGE_USER&apos;: return &#123; ...state,userName:action.userName,userId:action.userId&#125; case &apos;LOGOUT&apos;: return &#123;...state,userName:&apos;&apos;,userId:&apos;&apos;&#125; default: return state &#125;&#125; 这里使用了ES6的扩展运算符（…）创建新的state对象，避免直接修改之前的state对象。 在实际项目中，可能会有很多reducer，就需要把reducer拆分保存在单独的文件中。Redux提供了一个combineReducers函数，用来合并reducer。 12345678910import &#123;combineReducers&#125; from &apos;redux&apos;;import pageHeaderReducer from &apos;./pageHeader.js&apos;;import userReducer from &apos;./userReducer&apos;;const appReducer = combineReducers(&#123; pageHeaderReducer, userReducer,&#125;);export default appReducer; storestore是Redux中的一个对象，作为action和reducer之间的一个桥梁。作用： 保存应用状态 通过方法获取应用状态 通过dispatch(action)发送更新状态的指令 通过方法subscribe(listener)注册监听函数、监听状态的改变。 总结下Redux中的数据流过程： （1）通过调用store.dispatch(action)。一个action描述了“发生了什么”的对象以及可能会携带一些参数。store.dispatch(action)可以在应用中任何位置调用。 （2）Redux的store调用reducer函数。store传递两个参数给reducer，分别是当前应用的状态和action，reducer必须是纯函数。 （3）根reducer可以把多个子reducer合并在一起，返回组成最终的应用状态。利用combineReducers进行组合。 （4）Redux的store保存根reducer返回的完整应用状态，这整个流程走完，应用状态才完成更新。 在React中使用Redux基础安装使用方法已经在第一篇中做了介绍，此处重点介绍下connect中的mapStateToProps和mapDispatchToProps。 mapStateToPropsmapStateToProps是一个函数，从名字上看，该函数作用就是把state转换成props。state就是Redux store中保存的应用状态，会作为参数传递给mapStateToProps，props就是被连接展示组件的props。 1234567const mapStateToProps = (state) =&gt; &#123; return &#123; userName:state.userReducer.userName, userImage:state.userReducer.userImage, userId:state.userReducer.userId &#125;&#125; 当store中的state改变后，mapStateToProps就会重新执行，重新计算传递给展示组件的props，从而触发组件的重新渲染。 注意：store中的state改变一定会导致mapStateToProps重新执行，但却不一定会触发组件渲染render方法重新执行。如果mapStateToProps新返回的对象和之前的对象浅比较相等，组件的shouldComponentUpdate方法就会返回false，组件的render方法就不会被再次触发，这也是一个重要优化吧！ mapDispatchToPropsmapDispatchToProps接收store.dispatch方法作为参数，返回展示组件用来修改state的函数。 12345const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; getOrder: (data) =&gt; dispatch(actionCreator(data)) &#125;&#125; 另外一种写法，利用bindActionCreators 1234567import &#123; bindActionCreators &#125; from &quot;redux&quot;;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return bindActionCreators(&#123; getOrder: actionCreator.getOrder &#125;,dispatch);&#125; bindActionCreators作用是将单个或多个ActionCreator转化为dispatch(action)的函数集合形式。个人感觉会内部自动注入dispatch，不用我们手动去dispatch。之后通过connect连接即可12345678910111213const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return bindActionCreators(&#123; login: authActions.login &#125;,dispatch);&#125;Login=connect(mapStateToProps,mapDispatchToProps)(Login) 注意connect函数参数必须第一个为mapStateToProps，第二个必须为mapDispatchToProps，可以不写mapDispatchToProps，但是如果需要mapDispatchToProps却不能不写mapStateToProps，否则会报错，个人第一次使用就犯了这个错误😓 啰哩啰嗦的说了这么多，码字不易，点赞再走哈。完整项目代码在github,欢迎点个star，不胜感激👏👏👏]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React构建精简版本掘金（四）]]></title>
    <url>%2F2019%2F04%2F03%2Freact-juejin4%2F</url>
    <content type="text"><![CDATA[到目前为止，首页、文章详情页、动态页、话题页及小册页面内容完成了，看一下效果图哈，数据不全，见谅哈！ 实现过程动态页该页面从布局来说分左右两部分，左边有分为输入框和已发表内容部分。 输入框部分 我这里采用了ant-design中的input作为输入框，而掘金是采用了可编辑的div来实现输入内容,通过设置contenteditable=”true”实现，感兴趣的小伙伴可查阅相关资料。发布按钮的disabled状态将根据输入框是否有值来决定。功能类似todolist添加功能，可参考文章详情页面的发布评论功能。 1234567891011121314151617181920212223&lt;div style=&#123;&#123;background:&apos;#fff&apos;,padding:&apos;15px&apos;,position:&apos;relative&apos;&#125;&#125;&gt; &lt;TextArea placeholder=&quot;告诉你个小秘密，发沸点时添加话题会被更多小伙伴看见呦~&quot; style=&#123;&#123;paddingBottom:&apos;30px&apos;&#125;&#125; autosize=&#123;&#123; minRows: 3&#125;&#125; onChange=&#123;this.handelInputChange.bind(this)&#125;/&gt; &#123;this.state.selectedTopic!==&apos;&apos;?&lt;span style=&#123;&#123;position:&apos;absolute&apos;,bottom:&apos;60px&apos;,left:&apos;28px&apos;,padding:&apos;0 12px&apos;,border:&apos;1px solid #007fff&apos;,userSelect:&apos;none&apos;,height:&apos;22px&apos;,borderRadius:&apos;14px&apos;,color:&apos;#007fff&apos;&#125;&#125;&gt;&#123;this.state.selectedTopic&#125;&lt;/span&gt;:&apos;&apos;&#125; &lt;div style=&#123;&#123;marginTop:&apos;5px&apos;,display:&apos;flex&apos;,justifyContent:&apos;space-between&apos;&#125;&#125;&gt; &lt;ul style=&#123;sy1&#125;&gt; &lt;li style=&#123;sy2&#125; onClick=&#123;this.handleBtn.bind(this,&apos;exp&apos;)&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/emoji.5594dbb.svg&apos; /&gt;表情 &lt;/li&gt; &lt;li style=&#123;sy2&#125; onClick=&#123;this.handleBtn.bind(this,&apos;pic&apos;)&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/active_file.d265f4e.svg&apos; /&gt;图片 &lt;/li&gt; &lt;li style=&#123;sy2&#125; onClick=&#123;this.handleBtn.bind(this,&apos;link&apos;)&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/active_link.b1a6832.svg&apos; /&gt;链接 &lt;/li&gt; &lt;Popover placement=&quot;bottom&quot; content=&#123;&lt;TopicList handleTopic=&#123;this.handleTopic.bind(this)&#125; /&gt;&#125; trigger=&quot;click&quot;&gt; &lt;li style=&#123;sy2&#125; onClick=&#123;this.handleBtn.bind(this,&apos;topic&apos;)&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/topic.6a87bb7.svg&apos; /&gt;话题 &lt;/li&gt; &lt;/Popover&gt; &lt;/ul&gt; &lt;Button type=&quot;primary&quot; disabled=&#123;this.state.disabledBtn&#125; onClick=&#123;this.handlePressEnter.bind(this)&#125;&gt;发布&lt;/Button&gt; &lt;/div&gt;&lt;/div&gt; 输入框内容发生变化事件 123456789101112handelInputChange=(e)=&gt;&#123; if(e.target.value.trim()!==&apos;&apos;)&#123; this.setState(&#123; disabledBtn:false, inputValue:e.target.value &#125;) &#125;else&#123; this.setState(&#123; disabledBtn:true &#125;) &#125;&#125; 发布按钮事件 1234567handlePressEnter=()=&gt;&#123; if(this.state.inputValue!==&apos;&apos;)&#123; console.log(&apos;发布沸点&apos;) &#125;else&#123; message.error(&apos;请输入沸点内容&apos;); &#125;&#125; 添加话题 如图所示，一个搜索框加一个话题列表。dom结构如下：123456789101112131415161718192021&lt;div style=&#123;&#123;background:&apos;#fff&apos;&#125;&#125;&gt; &lt;Search placeholder=&quot;搜索话题&quot; onSearch=&#123;value =&gt; this.handleSearch(value)&#125; style=&#123;&#123; width: &apos;100%&apos; &#125;&#125; /&gt; &lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;this.state.topicListData&#125; style=&#123;&#123;height:&apos;300px&apos;,overflow:&apos;auto&apos;&#125;&#125; renderItem=&#123;item =&gt; ( &lt;List.Item style=&#123;&#123;cursor:&apos;pointer&apos;&#125;&#125; onClick=&#123;this.handleClick.bind(this,item.title)&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar size=&#123;42&#125; shape=&quot;square&quot; src=&#123;item.img&#125; /&gt;&#125; title=&#123;item.title&#125; description=&#123;&lt;div&gt;&#123;item.followers&#125;关注 &#123;item.num&#125;沸点&lt;/div&gt;&#125; /&gt; &lt;/List.Item&gt; )&#125; /&gt;&lt;/div&gt; 搜索框回车搜索事件： 12345678910111213handleSearch=(value)=&gt;&#123; const list=[...this.state.storeListData]; if(value!==&apos;&apos;)&#123; const searchList=list.filter(item=&gt;item.title.indexOf(value)&gt;-1); this.setState(&#123; topicListData:searchList &#125;) &#125;else&#123; this.setState(&#123; topicListData:list &#125;) &#125;&#125; 话题列表点击事件： 123handleClick=(val)=&gt;&#123; this.props.handleTopic(val);&#125; 这里向父组件传递了一个val代表当前点击话题，关于父子组件传值的相关说明前面文章做了介绍，这里不再赘述。 已发表的话题列表使用ant-design的list组件实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152render() &#123; const IconText = (&#123; type, text,tag &#125;) =&gt; ( &lt;span onClick=&#123;this.handleClick.bind(this,tag)&#125;&gt; &lt;Icon type=&#123;type&#125; style=&#123;&#123; marginRight: 8 &#125;&#125; /&gt; &#123;text&#125; &lt;/span&gt; ); const PopoverContent=(id)=&gt;&#123; return &lt;p style=&#123;&#123;cursor:&apos;pointer&apos;&#125;&#125; onClick=&#123;this.handleReport.bind(this,id)&#125;&gt;举报&lt;/p&gt; &#125; return ( &lt;div&gt; &lt;List itemLayout=&quot;vertical&quot; size=&quot;large&quot; dataSource=&#123;this.state.listData&#125; renderItem=&#123;item =&gt; ( &lt;List.Item key=&#123;item.author&#125; actions=&#123; [ &lt;IconText type=&quot;like&quot; text=&#123;item.likeNum===0?&apos;赞&apos;:item.likeNum&#125; tag=&apos;like&apos; /&gt;, &lt;IconText type=&quot;message&quot; text=&#123;item.commentNum===0?&apos;评论&apos;:item.commentNum&#125; tag=&apos;comment&apos; /&gt;, &lt;IconText type=&quot;share-alt&quot; text=&quot;分享&quot; tag=&apos;share&apos; /&gt; ] &#125; extra=&#123; &lt;div&gt; &#123;!item.isFollowed &amp;&amp; &lt;Button style=&#123;&#123;borderColor:&apos;#6cbd45&apos;,color:&apos;#6cbd45&apos;&#125;&#125; onClick=&#123;()=&gt;this.handleFollow(item.id)&#125;&gt;&#123;item.isFollowed?&apos;已关注&apos;:&apos;关注&apos;&#125;&lt;/Button&gt;&#125; &lt;Popover placement=&quot;bottom&quot; content=&#123;&lt;PopoverContent author=&#123;item.author&#125; /&gt;&#125; trigger=&quot;click&quot;&gt; &lt;span style=&#123;&#123;cursor:&apos;pointer&apos;,margin:&apos;10px&apos;&#125;&#125;&gt;...&lt;/span&gt; &lt;/Popover&gt; &lt;/div&gt; &#125; &gt; &lt;List.Item.Meta // avatar=&#123;&lt;Avatar size=&#123;45&#125; src=&#123;item.avatar&#125; /&gt;&#125; avatar=&#123;&lt;Popover placement=&quot;top&quot; content=&#123;&lt;PersonalPop info=&#123;item&#125; handleFollow=&#123;(id)=&gt;this.handleFollow(id)&#125; /&gt;&#125;&gt; &lt;Avatar size=&#123;45&#125; src=&#123;item.avatar&#125; /&gt; &lt;/Popover&gt;&#125; title=&#123;&lt;Popover placement=&quot;top&quot; content=&#123;&lt;PersonalPop info=&#123;item&#125; handleFollow=&#123;(id)=&gt;this.handleFollow(id)&#125; /&gt;&#125;&gt; &lt;span style=&#123;&#123;cursor:&apos;pointer&apos;&#125;&#125;&gt;&#123;item.author&#125;&lt;/span&gt; &lt;/Popover&gt;&#125; description=&#123;&lt;div&gt;&lt;span&gt;&#123;item.description&#125;&lt;/span&gt;&lt;span style=&#123;&#123;margin:&apos;0 5px&apos;&#125;&#125;&gt;·&lt;/span&gt;&lt;span&gt;&#123;timeUtil.getTimeAgo(item.editTime)&#125;&lt;/span&gt;&lt;/div&gt;&#125; /&gt; &#123;item.content&#125; &lt;/List.Item&gt; )&#125; /&gt; &lt;/div&gt; );&#125; 用户头像鼠标滑过会出现详情，使用了popover组件，具体内容是单独抽离的一个PersonalPop组件。每一项根据isFollowed值判断是否显示关注按钮，如果没有关注，点击可关注。 右侧内容右侧内容统一使用card组件实现，利用Redux获取登录用户信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758render() &#123; const &#123; Meta &#125; = Card; return ( &lt;div className=&apos;dynamicSide&apos;&gt; &lt;Card style=&#123;&#123; width: &apos;100%&apos; &#125;&#125; className=&apos;card1&apos;&gt; &lt;Meta avatar=&#123;&lt;Avatar size=&#123;62&#125; src=&#123;this.props.userImage&#125; /&gt;&#125; title=&#123;this.props.userId&#125; description=&#123;this.props.userDesc&#125; /&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;p className=&apos;liTitle&apos;&gt;沸点&lt;/p&gt; &lt;p className=&apos;liNum&apos;&gt;&#123;this.state.userInfo.topNum&#125;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p className=&apos;liTitle&apos;&gt;关注&lt;/p&gt; &lt;p className=&apos;liNum&apos;&gt;&#123;this.state.userInfo.following&#125;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p className=&apos;liTitle&apos;&gt;关注者&lt;/p&gt; &lt;p className=&apos;liNum&apos;&gt;&#123;this.state.userInfo.follower&#125;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/Card&gt; &lt;Card title=&quot;你可能感兴趣的人&quot; style=&#123;&#123; width: &apos;100%&apos; ,marginTop:&apos;10px&apos;&#125;&#125; className=&apos;card2&apos; &gt; &lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;this.state.interestList&#125; renderItem=&#123;item =&gt; ( &lt;List.Item actions=&#123;[&lt;Button&gt;关注&lt;/Button&gt;]&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar size=&#123;40&#125; src=&#123;item.userImage&#125; /&gt;&#125; title=&#123;item.user&#125; description=&#123;item.desc&#125; /&gt; &lt;/List.Item&gt; )&#125; /&gt; &lt;div className=&apos;user-recommend-footer&apos; onClick=&#123;this.changeInterestList.bind(this)&#125;&gt; &lt;Icon type=&quot;sync&quot; /&gt;换一批 &lt;/div&gt; &lt;/Card&gt; &lt;div style=&#123;&#123;marginTop:&apos;10px&apos;&#125;&#125;&gt; &lt;TopicCard title=&apos;关注的话题&apos; link=&apos;/topics&apos; list=&#123;this.state.attentionTopic&#125; /&gt; &lt;/div&gt; &lt;div style=&#123;&#123;marginTop:&apos;10px&apos;&#125;&#125;&gt; &lt;TopicCard title=&apos;更多话题&apos; link=&apos;/topics&apos; list=&#123;this.state.allTopic&#125; /&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 鉴于关注的话题和更多话题内容结构类似，故抽离为一个公用组件，且为函数式组件。 123456789101112131415161718192021222324function TopicCard(&#123; title,list,link &#125;)&#123; return ( &lt;Card title=&#123;title&#125; extra=&#123;&lt;a href=&#123;link&#125; style=&#123;&#123;color:&apos;#007fff&apos;&#125;&#125;&gt;全部&gt;&lt;/a&gt;&#125; style=&#123;&#123; width: &apos;100%&apos; &#125;&#125; className=&apos;topicCard&apos; &gt; &lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;list&#125; renderItem=&#123;item =&gt; ( &lt;List.Item&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar shape=&quot;square&quot; size=&#123;40&#125; src=&#123;item.userImage&#125; /&gt;&#125; title=&#123;item.title&#125; description=&#123;&lt;div style=&#123;&#123;color:&apos;#8a9aa9&apos;&#125;&#125;&gt;&lt;span&gt;&#123;item.followNum&#125;关注&lt;/span&gt;·&lt;span&gt;&#123;item.hotNews&#125;沸点&lt;/span&gt;&lt;/div&gt;&#125; /&gt; &lt;/List.Item&gt; )&#125; /&gt; &lt;/Card&gt; );&#125; React组件可分为函数组件(Functional Component )和类组件(Class Component)，划分依据是根据组件的定义方式。函数组件使用函数定义组件，类组件使用ES6 class定义组件。 函数组件的写法要比类组件简洁，不过类组件比函数组件功能更强大。类组件可以维护自身的状态变量，即组件的state，类组件还有不同的生命周期方法，可以让我们能够在组件的不同阶段（挂载、更新、卸载）对组件做更多的控制，进行不同的操作。但函数组件的使用可以从思想上让你在设计组件时进行更多思考，更加关注逻辑控制和显示的分离，设计出更加合理的组件结构。实际操作中，当一个组件不需要管理自身状态时，可以把它设计成函数组件，当你有足够的理由发现它需要“升级”为类组件时，再把它改造为类组件。因为函数组件“升级”为类组件是有一定成本的，这样就会要求你做这个改造前更认真地思考其合理性，而不是仅仅为了一时的方便就使用类组件。 话题页同样适用函数式组件 12345678910111213141516171819202122function TopicItem(&#123;item,showCount&#125;)&#123; const &#123;id,topicName,topicImage,topicCount,followedNum,topicNum,isFollowed&#125;=item; return ( &lt;div className=&apos;topicItem&apos;&gt; &lt;Badge count=&#123;showCount?topicCount:0&#125; overflowCount=&#123;999&#125;&gt; &lt;Avatar shape=&quot;square&quot; size=&#123;72&#125; src=&#123;topicImage&#125; /&gt; &lt;/Badge&gt; &lt;div style=&#123;&#123;marginLeft:&apos;15px&apos;&#125;&#125;&gt; &lt;div&gt; &lt;NavLink to=&#123;`/topic/$&#123;id&#125;`&#125;&gt;&#123;topicName&#125;&lt;/NavLink&gt; &lt;/div&gt; &lt;div style=&#123;&#123;color:&apos;#8a9aa9&apos;,marginTop:&apos;5px&apos;&#125;&#125;&gt; &lt;span&gt;&#123;followedNum&#125;关注&lt;/span&gt;· &lt;span&gt;&#123;topicNum&#125;沸点&lt;/span&gt; &lt;/div&gt; &lt;div className=&#123;isFollowed?&apos;hasFollowed&apos;:&apos;noFollow&apos;&#125;&gt; &#123;isFollowed?&apos;已关注&apos;:&apos;+关注&apos;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; );&#125; 关注的话题数据其实是全部话题的子集，在父页面调用的时候根据数据中的isFollowed属性进行一次筛选。 1234567componentDidMount()&#123; const list=[...this.state.allTopicList]; const followedTopicList=list.filter(item=&gt;item.isFollowed); this.setState(&#123; followedTopic:[...followedTopicList] &#125;)&#125; 小册页 头部的导航 1234567891011function TopNav(&#123;tags,changeLink&#125;)&#123; return ( &lt;ul&gt; &#123;tags.map((item,index)=&gt;&#123; return &lt;li key=&#123;item.path&#125; onClick=&#123;()=&gt;changeLink(item.path)&#125;&gt; &lt;NavLink to=&#123;`/books$&#123;item.path&#125;`&#125;&gt;&#123;item.text&#125;&lt;/NavLink&gt; &lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 小册列表使用ant-design中的list组件进行基本布局 123456789101112131415161718192021222324252627282930313233343536render() &#123; return ( &lt;div&gt; &lt;List size=&quot;large&quot; bordered dataSource=&#123;this.state.bookList&#125; renderItem=&#123;item =&gt; ( &lt;List.Item className=&apos;bookList&apos; onClick=&#123;()=&gt;this.showInfo(item.bookId)&#125;&gt; &lt;img alt=&apos;books&apos; src=&#123;item.img&#125; /&gt; &lt;div&gt; &lt;div style=&#123;&#123;color:&apos;#000&apos;,fontSize:&apos;20px&apos;,fontWeight:400&#125;&#125;&gt; &#123;item.isPresell &amp;&amp; &lt;span className=&quot;presale&quot;&gt;预售&lt;/span&gt; &#125; &lt;span className=&apos;bookName&apos;&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;div className=&apos;bookDesc&apos;&gt;&#123;item.desc&#125;&lt;/div&gt; &lt;div className=&apos;bookAuthor&apos;&gt; &lt;NavLink to=&#123;`/user/:$&#123;item.userId&#125;`&#125;&gt; &lt;Avatar size=&#123;26&#125; src=&#123;item.userImage&#125; /&gt; &lt;span style=&#123;&#123;color:&apos;#000&apos;,marginLeft:&apos;5px&apos;&#125;&#125;&gt;&#123;item.author&#125;&lt;/span&gt; &lt;/NavLink&gt; &lt;span style=&#123;&#123;color:&apos;#71777c&apos;,margin:&apos;0 10px&apos;,whiteSpace:&apos;nowrap&apos;,overflow:&apos;hidden&apos;&#125;&#125;&gt;&#123;item.selfDesc&#125;&lt;/span&gt; &lt;/div&gt; &lt;div className=&apos;other&apos;&gt; &#123;item.isBuy?&lt;span className=&apos;bought&apos;&gt;已购买&lt;/span&gt;:&lt;span className=&apos;price&apos;&gt;￥&#123;item.price&#125;&lt;/span&gt;&#125; &lt;span className=&apos;message&apos;&gt;&#123;item.chapterNum&#125;小节&lt;/span&gt; &#123;item.isBuy &amp;&amp; &lt;span className=&apos;message&apos;&gt;阅读时长&#123;item.readTime&#125;分&lt;/span&gt;&#125; &lt;span className=&apos;message&apos;&gt;&#123;item.purchaseNum&#125;购买&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/List.Item&gt; )&#125; /&gt; &lt;/div&gt; );&#125; 会根据属性是否预售isPresell和是否已经购买isBuy来判断显示不同内容。 相关文章 使用React构建精简版本掘金（一） 使用React构建精简版本掘金（二） 使用React构建精简版本掘金（三） 相关详细代码可查看github,不要忘了star哦！工作中主要是以vue作为主要技术栈，这是第一次使用React+React-router+Redux来构建项目，不足之处还请大家多多包涵。 金三已过，银四会是什么样子呢？]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React构建精简版本掘金（三）]]></title>
    <url>%2F2019%2F03%2F20%2Freact-juejin3%2F</url>
    <content type="text"><![CDATA[抽了两天工作中闲暇时间，文章详情页终于写完了，先上图哈，截图少了下面一部分哈，见谅！ 本篇文章为使用React构建精简版本掘金系列第三篇，想看前两篇的话，请查看第一篇,第二篇。整理一下详情页用到的一些知识点： redux存储、取值 React-router路由跳转传值 父子组件传值 实现过程左侧部分主要包含点赞数量显示、评论数量、收藏按钮，分享链接等。由于要常驻在左侧，且页面滚动过程中位置不变，故使用fixed定位方式，并且使用ant-design中的Avatar,Badge,Icon,Popover组件。 1234567891011121314151617181920212223242526272829import &#123; Avatar,Badge,Icon,Popover &#125; from &apos;antd&apos;;...&lt;div style=&#123;articleSuspendedPanel&#125;&gt; &lt;Badge count=&#123;this.props.starCount&#125; overflowCount=&#123;this.state.overflowCount&#125; style=&#123;badgeSy&#125;&gt; &lt;div style=&#123;panelCircleSy&#125;&gt; &lt;Icon type=&quot;like&quot; theme=&quot;filled&quot; style=&#123;IconSy&#125;/&gt; &lt;/div&gt; &lt;/Badge&gt; &lt;Badge count=&#123;this.props.commentsCount&#125; overflowCount=&#123;this.state.overflowCount&#125; style=&#123;badgeSy&#125;&gt; &lt;div style=&#123;panelCircleSy&#125;&gt; &lt;Icon type=&quot;message&quot; theme=&quot;filled&quot; style=&#123;IconSy&#125;/&gt; &lt;/div&gt; &lt;/Badge&gt; &lt;div style=&#123;panelCircleSy&#125;&gt; &lt;Icon type=&quot;star&quot; theme=&quot;filled&quot; style=&#123;IconSy&#125;/&gt; &lt;/div&gt; &lt;label&gt;分享&lt;/label&gt; &lt;Avatar style=&#123;avatarSy1&#125;&gt; &lt;img alt=&quot;&quot; src=&quot;//b-gold-cdn.xitu.io/v3/static/img/weibo.2076a57.svg&quot; /&gt; &lt;/Avatar&gt; &lt;Avatar style=&#123;avatarSy1&#125;&gt; &lt;img alt=&quot;&quot; src=&quot;//b-gold-cdn.xitu.io/v3/static/img/qq.0834411.svg&quot; /&gt; &lt;/Avatar&gt; &lt;Popover content=&#123;&lt;QRCode value=&#123;window.location.href+&apos;/post/&apos;+this.props.wxShareAddr&#125; /&gt;&#125; placement=&quot;bottom&quot;&gt; &lt;Avatar style=&#123;avatarSy1&#125;&gt; &lt;img alt=&quot;&quot; src=&quot;//b-gold-cdn.xitu.io/v3/static/img/wechat.63e1ce0.svg&quot; /&gt; &lt;/Avatar&gt; &lt;/Popover&gt;&lt;/div&gt; render中的代码结构如上，starCount和commentsCount数据是从父级组件传入的，微信分享扫一扫利用了QRCode组件，关于该组件的介绍可查看上一篇文章，有详细的说明。 中间部分（重点）仔细看的话，其实中间部分也可以分为顶部的作者介绍，包括文章编辑时间，阅读量，登录用户是否关注了作者。第二部分才是真正的文章详情。第三部分有关于该文章的评论区域，最下面是一系列的相关推荐文章。接下来分别介绍下： 顶部12345678910111213&lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;this.state.articleInfo.articleList&#125; renderItem=&#123;item =&gt; ( &lt;List.Item actions=&#123;[item.isFocus?&lt;button className=&apos;focusedBtn&apos;&gt;已关注&lt;/button&gt;:&lt;button className=&apos;focusBtn&apos;&gt;关注&lt;/button&gt;]&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar src=&#123;item.authorImage&#125; /&gt;&#125; title=&#123;item.author&#125; description=&#123;&lt;div&gt;&lt;span&gt;&#123;item.editDate&#125;&lt;/span&gt;&lt;span style=&#123;&#123;marginLeft:&apos;10px&apos;&#125;&#125;&gt;阅读&#123;item.readNum&#125;&lt;/span&gt;&lt;/div&gt;&#125; /&gt; &lt;/List.Item&gt; )&#125;/&gt; 很简单的一部分，应该能看明白。 中间部分中间部分我这里就简单的用section包裹内容了，实际开发中个人觉得应该需要读取对应各层标题的样式、正文的样式，分段落显示，需要去分类型解析各种内容，包括图片、超链接等内容。 评论区域布局问题就不说了，重点说一下输入框评论功能实现，其实类似大家常说的todolist功能。输入内容，点击评论按钮或者直接回车，评论内容添加到评论列表，输入框内容清空。 123456789101112131415161718&lt;div style=&#123;&#123;marginLeft:&apos;10px&apos;,flex:&apos;1&apos;&#125;&#125;&gt; &lt;div&gt; &lt;Input value=&#123;this.state.value&#125; placeholder=&quot;输入评论...&quot; onFocus=&#123;this.handleFocus.bind(this)&#125; onChange=&#123;this.handleChange.bind(this)&#125; onPressEnter=&#123;this.handlePressEnter.bind(this)&#125;/&gt; &lt;/div&gt; &#123; this.state.showIconAndBtn? &lt;div style=&#123;&#123;display:&apos;flex&apos;,justifyContent:&apos;space-between&apos;,marginTop:&apos;10px&apos;&#125;&#125;&gt; &lt;span style=&#123;&#123;color:&apos;#027fff&apos;,cursor: &apos;pointer&apos;,display:&apos;flex&apos;,alignItems:&apos;center&apos;&#125;&#125; onClick=&#123;info&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/emoji.5594dbb.svg&apos; /&gt; 表情 &lt;/span&gt; &lt;p&gt; &lt;label style=&#123;&#123;color:&apos;#c2c2c2&apos;,marginRight:&apos;8px&apos;&#125;&#125;&gt;Enter&lt;/label&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;this.handlePressEnter.bind(this)&#125;&gt;评论&lt;/Button&gt; &lt;/p&gt; &lt;/div&gt;:&apos;&apos; &#125;&lt;/div&gt; showIconAndBtn是控制输入框下面那一行是否显示的，初始进入页面的时候是只能看到输入框，下面的表情和评论按钮只能等输入框获取焦点后才能显示。 输入框上绑定了三个事件，分别用来处理获取焦点事件、输入内容改变事件、按下回车事件。 获取焦点事件 12345handleFocus=()=&gt;&#123; this.setState(&#123; showIconAndBtn:true &#125;)&#125; 输入内容改变事件 12345handleChange=(e)=&gt;&#123; this.setState(&#123; value:e.target.value &#125;);&#125; 回车事件（后面的评论按钮功能相同） 1234567891011handlePressEnter=()=&gt;&#123; if(this.state.value!==&apos;&apos;)&#123; this.props.submitComment(this.state.value);//调用父级组件并传值 this.setState(&#123; value:&apos;&apos;, showIconAndBtn:false &#125;) &#125;else&#123; message.warning(&apos;还未填写评论哦！&apos;); &#125;&#125; 这里有用到子组件向父组件传值的方法，简单介绍下：父向子传值 父向子传值起始比较简单，重点要考虑向下传值是否会使得父组件中的状态过于繁杂，是否会影响页面性能。 假设存在一个组件ComponentA，在父组件中调用ComponentA，并且传递参数data 123456...this.state=&#123; text:&apos;hello world&apos;&#125;...&lt;ComponentA data=&#123;this.state.text&#125; / 在组件ComponentA中就可以通过this.props.data获取到父组件传入的data值了。子向父传值 由子组件的事件触发，在触发的函数体中调用父组件传入的方法，将子组件里的值传入即可。 假设存在父组件ComponentParent，子组件ComponentChild,父组件中调用ComponentChild 父组件：123456...handleChange=(val)=&gt;&#123; console.log(`信息:`+val);//子组件传入的数据&#125;...&lt;ComponentChild change=&#123;this.handleChange.bind(this)&#125; /&gt; 子组件： 1234//假设有个方法叫handleClickhandleClick=()=&gt;&#123; this.props.change(&apos;hello&apos;);&#125; 在子组件中执行handleClick方法的时候就会触发父组件中的方法handleChange，并在控制台输出hello。 兄弟组件传值 可以将数据提升到共同的父组件中，进行传值，之后在利用父子组件传值即可。 多层级组件或者称为不相邻组件传值 可以利用redux管理全局状态，之后在任何地方都可以取到对应的数据。 这种方式的使用方式在第一篇文章做了说明，可以浏览哦！ 待实现功能： 表情组件 评论列表区域个人实现的这块区域和掘金有少许不同。 123456789101112131415161718&lt;List itemLayout=&quot;vertical&quot; size=&quot;large&quot; dataSource=&#123;this.props.commentList&#125; renderItem=&#123;item =&gt; ( &lt;List.Item key=&#123;item.userId&#125; actions=&#123;[&lt;span&gt;&#123;moment().subtract(item.editDate, &apos;days&apos;).fromNow()&#125;&lt;/span&gt;,&lt;IconText type=&quot;like-o&quot; text=&#123;item.starNum&#125; /&gt;, &lt;IconText type=&quot;message&quot; text=&#123;item.commentNum&#125; /&gt;]&#125; &gt; &lt;List.Item.Meta avatar=&#123;&lt;a href=&#123;&apos;/user/&apos;+item.userId&#125;&gt;&lt;Avatar src=&#123;item.userImage&#125; /&gt;&lt;/a&gt;&#125; title=&#123;&lt;div&gt;&#123;item.authorName&#125;&lt;/div&gt;&#125; description=&#123;item.userDesc&#125; /&gt; &#123;item.commentText&#125; &lt;/List.Item&gt; )&#125;/&gt; 采用了ant-design中的List组件进行显示待实现 嵌套评论列表 相关推荐列表该部分结构采用了首页列表组件，只需按照文章类型，推荐不同内容即可，这里不再赘述。 右侧部分右侧整体结构和首页右侧内容类似，分6块： 关于作者 123456789101112131415161718192021222324252627282930313233343536&lt;Card title=&quot;关于作者&quot; style=&#123;&#123; width: &apos;100%&apos; &#125;&#125; hoverable=&#123;&apos;true&apos;&#125; headStyle=&#123;&#123;fontSize:&apos;14px&apos;,color:&apos;#333&apos;&#125;&#125; bodyStyle=&#123;&#123;padding:&apos;0 16px&apos;&#125;&#125; &gt; &lt;List itemLayout=&quot;vertical&quot; dataSource=&#123;this.props.author&#125; renderItem=&#123;item =&gt; ( &lt;List.Item onClick=&#123;()=&gt;window.location.href=&apos;/user/&apos;+item.id&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar size=&#123;46&#125; src=&#123;item.authorImage&#125; /&gt;&#125; title=&#123;item.author&#125; /&gt; &#123;item.isGroup?&lt;div&gt; &lt;Avatar style=&#123;&#123; backgroundColor: &apos;#e1efff&apos;,color:&apos;#7bb9ff&apos; &#125;&#125; icon=&quot;user&quot; /&gt; &lt;label style=&#123;&#123;color:&apos;#000&apos;,marginLeft:&apos;10px&apos;,fontSize:&apos;16px&apos;&#125;&#125;&gt;联合编辑&lt;/label&gt; &lt;/div&gt;:&apos;&apos;&#125; &lt;div style=&#123;&#123;marginTop:&apos;10px&apos;&#125;&#125;&gt; &lt;Avatar style=&#123;&#123; backgroundColor: &apos;#e1efff&apos; &#125;&#125;&gt; &lt;Icon type=&quot;like&quot; theme=&quot;filled&quot; style=&#123;&#123;color:&apos;#7bb9ff&apos;&#125;&#125; /&gt; &lt;/Avatar&gt; &lt;label style=&#123;&#123;color:&apos;#000&apos;,marginLeft:&apos;10px&apos;,fontSize:&apos;16px&apos;&#125;&#125;&gt;获得赞数&#123;item.allStarNum&#125;&lt;/label&gt; &lt;/div&gt; &lt;div style=&#123;&#123;marginTop:&apos;10px&apos;&#125;&#125;&gt; &lt;Avatar style=&#123;&#123; backgroundColor: &apos;#e1efff&apos; &#125;&#125;&gt; &lt;Icon type=&quot;eye&quot; theme=&quot;filled&quot; style=&#123;&#123;color:&apos;#7bb9ff&apos;&#125;&#125; /&gt; &lt;/Avatar&gt; &lt;label style=&#123;&#123;color:&apos;#000&apos;,marginLeft:&apos;10px&apos;,fontSize:&apos;16px&apos;&#125;&#125;&gt;获得阅读数&#123;item.allReadNum&lt;99999?item.allReadNum:&apos;99999+&apos;&#125;&lt;/label&gt; &lt;/div&gt; &lt;/List.Item&gt; )&#125; /&gt;&lt;/Card&gt; 感兴趣的小册推荐 12345678910111213141516171819202122&lt;Card title=&quot;你可能感兴趣的小册&quot; style=&#123;&#123; width: &apos;100%&apos;,marginTop:&apos;20px&apos; &#125;&#125; hoverable=&#123;&apos;true&apos;&#125; headStyle=&#123;&#123;fontSize:&apos;14px&apos;,color:&apos;#333&apos;&#125;&#125; bodyStyle=&#123;&#123;padding:&apos;0 16px&apos;&#125;&#125; &gt; &lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;this.props.recommendBooks&#125; className=&quot;bookCard&quot; renderItem=&#123;item =&gt; ( &lt;List.Item onClick=&#123;()=&gt;window.location.href=&apos;/book/&apos;+item.id&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;img alt=&apos;&apos; src=&#123;item.bookImage&#125; /&gt;&#125; title=&#123;item.title&#125; description=&#123;&lt;p className=&quot;book-desc&quot;&gt;&lt;span&gt;&#123;item.sellNum+&apos;人已购买&apos;&#125;&lt;/span&gt;&lt;span className=&quot;try-read&quot;&gt;试读&lt;/span&gt;&lt;/p&gt;&#125; /&gt; &lt;/List.Item&gt; )&#125; /&gt;&lt;/Card&gt; 这一块单独抽一个组件，别的地方也可能会用到，后期只需传入小册内容即可。目前首页和文章详情页用的都是这个组件。 掘金客户端下载二维码 123456789&lt;Card style=&#123;&#123; width: &apos;100%&apos;,marginTop:&apos;20px&apos; &#125;&#125; hoverable=&apos;true&apos; className=&quot;download-card&quot; bodyStyle=&#123;&#123;padding:&apos;15px&apos;&#125;&#125;&gt; &lt;NavLink to=&apos;/app&apos;&gt; &lt;img alt=&apos;qrcode&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/timeline.e011f09.png&apos; /&gt; &lt;div&gt; &lt;div className=&quot;headline&quot;&gt;下载掘金客户端&lt;/div&gt; &lt;div className=&quot;desc&quot;&gt;一个帮助开发者成长的社区&lt;/div&gt; &lt;/div&gt; &lt;/NavLink&gt;&lt;/Card&gt; 掘金微信群 1234567&lt;Card style=&#123;&#123; width: &apos;100%&apos;,marginTop:&apos;20px&apos; &#125;&#125; hoverable=&#123;&apos;true&apos;&#125; bodyStyle=&#123;&#123;padding:&apos;0&apos;&#125;&#125;&gt; &lt;img alt=&apos;&apos; src=&apos;//b-gold-cdn.xitu.io/v3/static/img/backend.ba44b94.png&apos; style=&#123;&#123;height:&apos;200px&apos;,width:&apos;100%&apos;&#125;&#125; /&gt;&lt;/Card&gt; 相关文章列表 123456789101112131415161718192021&lt;Card title=&quot;相关文章&quot; headStyle=&#123;&#123;fontSize:&apos;14px&apos;,color:&apos;#333&apos;&#125;&#125; style=&#123;&#123; width: &apos;100%&apos;,marginTop:&apos;20px&apos;&#125;&#125; hoverable=&#123;&apos;true&apos;&#125; bodyStyle=&#123;&#123;padding:&apos;0 16px&apos;&#125;&#125; &gt; &lt;List itemLayout=&quot;vertical&quot; dataSource=&#123;this.props.relationArticles&#125; split=&#123;false&#125; renderItem=&#123;item =&gt; ( &lt;List.Item onClick=&#123;()=&gt;window.location.href=&apos;/post/&apos;+item.id&#125;&gt; &lt;div style=&#123;&#123;color:&apos;#333&apos;,fontSize:&apos;16px&apos;&#125;&#125;&gt;&#123;item.title&#125;&lt;/div&gt; &lt;div style=&#123;&#123;marginTop:&apos;10px&apos;,color:&apos;#b2bac2&apos;,fontSize:&apos;12px&apos;&#125;&#125;&gt; &lt;Icon type=&quot;like&quot; theme=&quot;filled&quot; style=&#123;&#123;marginRight:&apos;3px&apos;&#125;&#125; /&gt;&#123;item.starNum&#125; &lt;Icon type=&quot;message&quot; theme=&quot;filled&quot; style=&#123;&#123;marginLeft:&apos;15px&apos;,marginRight:&apos;3px&apos;&#125;&#125; /&gt;&#123;item.commentNum&#125; &lt;/div&gt; &lt;/List.Item&gt;)&#125; /&gt;&lt;/Card&gt; 文章目录 1234567&lt;div className=&apos;text-catalogue&apos;&gt; &lt;Timeline&gt; &#123;this.props.data.map((item,index)=&gt;&#123; return &lt;Timeline.Item color=&apos;#000&apos; key=&#123;item.text&#125; dot=&#123;&lt;span className=&apos;catalogue-circle&apos;&gt;&lt;/span&gt;&#125;&gt;&#123;(item.children &amp;&amp; item.children.length !== 0)?&lt;div&gt;&lt;a href=&#123;`#heading-$&#123;index&#125;`&#125;&gt;&#123;item.text&#125;&lt;/a&gt;&lt;div className=&apos;secondCatalogue&apos;&gt;&lt;Catalogue data=&#123;item.children&#125; /&gt;&lt;/div&gt;&lt;/div&gt;:&lt;a href=&#123;`#heading-$&#123;index&#125;`&#125;&gt;&#123;item.text&#125;&lt;/a&gt;&#125;&lt;/Timeline.Item&gt; &#125;)&#125; &lt;/Timeline&gt;&lt;/div&gt; 用到了ant-design中的Timeline组件，这个单独抽离成一个组件，整个系统中都可以复用，这里用到了递归组件实现目录嵌套的功能。 路由跳转传参从首页文章列表进入文章详情页的时候需要传递一些参数，比如文章的id值 方法一（本文采用了该方法） 第一步在路由文件中设置 1&lt;Route path=&apos;/post/:articleId&apos; component=&#123;Post&#125;/&gt; 第二步文章列表点击事件中 1234showArticleInfo=(id)=&gt;&#123; console.log(`文章id值：$&#123;id&#125;`); window.location.href=&apos;/post/&apos;+id;&#125; 第三步在进入文章详情页的时候就可以获取到文章id了。 1234componentDidMount()&#123; const &#123;match&#125;=this.props; console.log(`文章id：$&#123;match.params.articleId&#125;`);&#125; 方法二 第一步：定义路由 1&lt;Route path=&apos;/post&apos; component=&#123;Post&#125; /&gt; 第二步：传递方式 12345let data = &#123;id:3,name:sam&#125;;let path = &#123; pathname:&apos;/post&apos;, state:data,&#125; 链接跳转 1&lt;Link to=&#123;path&#125;&gt;详情&lt;/Link&gt; 第三步：获取 12let data = this.props.location.state;let &#123;id,name&#125; = data; 截止到目前为止，首页和文章详情页的结构和基本功能就算完成了，细节后续在优化，剩余部分陆续更新中。 上述详细代码请见github,不要忘了star和点赞哦，多谢！]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React构建精简版本掘金（二）]]></title>
    <url>%2F2019%2F03%2F20%2Freact-juejin1%2F</url>
    <content type="text"><![CDATA[咋一看，是不是感觉掘金改版了呢！如果你有这个错觉，那就说明我仿照的还算可以，我就当是对我的肯定吧，O(∩_∩)O~~ 首页顶部标签即我上面红框圈住的部分，这部分由于要做页面滚动的时候常驻顶部，个人为了简单省事，采用了ant-design中的Affix组件，另外导航组件我抽离了一个公用组件，从外部传入tags数组。 1234567891011121314151617181920212223import &#123; Affix&#125; from &apos;antd&apos;;...this.state=&#123; tags:[ &#123; path:&apos;recommended&apos;, text:&apos;推荐&apos; &#125;, &#123; path:&apos;following&apos;, text:&apos;关注&apos; &#125; ]&#125;...&lt;Affix offsetTop=&#123;this.state.top&#125;&gt; &lt;div className=&quot;home-nav&quot;&gt; &lt;nav&gt; &lt;HomeNav tags=&#123;this.state.tags&#125; match=&#123;match&#125;/&gt; &lt;a href=&quot;/&quot;&gt;标签管理&lt;/a&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/Affix&gt; HomeNav组件如下 12345678910111213141516171819202122import React, &#123; Component &#125; from &apos;react&apos;;import &#123; NavLink &#125; from &apos;react-router-dom&apos;...class HomeNav extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125; &#125; render() &#123; return ( &lt;ul&gt; &#123;this.props.tags.map((item,index)=&gt;&#123; return &lt;li key=&#123;item.path&#125;&gt; &lt;NavLink to=&#123;`/timeline/$&#123;item.path&#125;`&#125;&gt;&#123;item.text&#125;&lt;/NavLink&gt; &lt;/li&gt; &#125;)&#125; &lt;/ul&gt; ); &#125;&#125;export default HomeNav; 动作部分该部分的实现方式可参考上面tag标签实现部分，基本类似。头像部分我使用了ant-design中Avatar，用来代表用户或事物，支持图片、图标或字符展示。 文章列表部分列表部分使用了ant-design中list组件 列表结构实现12345678910111213import &#123; List,Statistic,Icon,Popover &#125; from &apos;antd&apos;;...const &#123;data&#125;=this.props;...&lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;data&#125; renderItem=&#123;item =&gt; ( &lt;List.Item extra=&#123;item.articleImage ? &lt;img width=&#123;80&#125; alt=&quot;logo&quot; src=&#123;item.articleImage&#125; /&gt;:&apos;&apos;&#125; onClick=&#123;this.showArticleInfo.bind(this,item.id)&#125;&gt; 添加内容 &lt;/List.Item&gt; )&#125;/&gt; 实际中data应该是根据传入的userID和标签去数据库查询得到的真实数据，我这里的data就从上一级中进行了获取。每一个listItem上面绑定了点击事件，最终需要跳转到文章详情页面。 列表内部结构 整体分成上中下三部分来实现布局,右侧的图片是在上一步listItem中配置extra属性可以实现。 123456789101112131415161718192021222324252627282930313233&lt;article&gt; &lt;section className=&quot;list-part1&quot;&gt; &lt;ul&gt; &lt;li className=&quot;item post&quot;&gt;&#123;item.articleType===&apos;1&apos;?&apos;专栏&apos;:&apos;小册&apos;&#125;&lt;/li&gt; &lt;li&gt;&#123;item.author&#125;&lt;/li&gt; &#123;item.time?&lt;li&gt;&#123;item.time&#125;&lt;/li&gt;:&apos;&apos;&#125; &#123;item.tags.length!==0?&lt;li&gt;&#123;item.tags.map((tag,index)=&gt;&#123; return &lt;NavLink key=&#123;tag&#125; to=&#123;`/tag/$&#123;tag&#125;`&#125;&gt;&#123;tag&#125;&lt;/NavLink&gt; &#125;)&#125;&lt;/li&gt;:&apos;&apos;&#125; &lt;/ul&gt; &lt;/section&gt; &lt;section className=&quot;list-part2&quot;&gt; &lt;NavLink to=&#123;`/post/:articleId`&#125;&gt;&#123;item.title&#125;&lt;/NavLink&gt; &lt;/section&gt; &lt;section className=&quot;list-part3&quot;&gt; &#123;item.articleType===&apos;1&apos;? &lt;div&gt; &lt;Statistic value=&#123;item.starNum&#125; prefix=&#123;&lt;Icon type=&quot;like&quot; theme=&quot;filled&quot; style=&#123;&#123; fontSize: &apos;14px&apos;&#125;&#125; /&gt;&#125; onClick=&#123;()=&gt;this.props.editStar(item.id)&#125; /&gt; &lt;Statistic value=&#123;item.commentNum&#125; prefix=&#123;&lt;Icon type=&quot;message&quot; theme=&quot;filled&quot; style=&#123;&#123; fontSize: &apos;14px&apos;&#125;&#125; onClick=&#123;()=&gt;this.props.lookComment(item.id)&#125; /&gt;&#125; /&gt; &lt;Icon type=&quot;upload&quot; style=&#123;&#123; fontSize: &apos;16px&apos;,marginLeft:&apos;10px&apos;,borderRight:&apos;none&apos;&#125;&#125; /&gt; &lt;Icon type=&quot;star&quot; theme=&quot;filled&quot; style=&#123;&#123; fontSize: &apos;16px&apos;&#125;&#125; onClick=&#123;()=&gt;this.props.collectArticle(item.id)&#125; /&gt; &lt;/div&gt;: &lt;div className=&quot;xiaoce-action-row&quot;&gt; &lt;span className=&quot;link-btn buy&quot;&gt;购买人数: &#123;item.sellNums&#125;&lt;/span&gt; &lt;span className=&quot;link-btn sale&quot;&gt;特价: &#123;item.price&#125;元&lt;/span&gt; &lt;span className=&quot;link-btn share&quot;&gt; &lt;Icon type=&quot;upload&quot; style=&#123;&#123; fontSize: &apos;16px&apos;,marginLeft:&apos;10px&apos;,borderRight:&apos;none&apos;&#125;&#125; onClick=&#123;()=&gt;this.props.shareArticle(item.id)&#125; /&gt; 分享 &lt;/span&gt; &lt;/div&gt; &#125; &lt;/section&gt;&lt;/article&gt; 掘金官网文章列表根据文章的类型是专栏还是小册显示不同的内容，即这里根据item的articleType进行了区分，这里用到了三目运算符做了显示控制渲染。React中条件渲染的方式有以下几种，补充下知识点：（1）if 语句（2）三目操作符（3）逻辑 &amp;&amp; 操作符（4）switch.. case.. 语句（5）枚举（6）多层条件渲染（7）使用高阶组件详情可查阅该文章 点击分享 安装qrcode.react插件 1yarn add qrcode.react --save 引入使用 123const QRCode = require(&apos;qrcode.react&apos;);...&lt;QRCode value=&#123;this.props.value&#125; /&gt; value值是从上一级组件传入的值,该插件属性描述：| prop | type | default value || ————- | ———————— | ————- || value | string | - || renderAs | string (‘canvas’ ‘svg’) | ‘canvas’ || size | number | 128 || bgColor | string (CSS color) | “#FFFFFF” || fgColor | string (CSS color) | “#000000” || level | string (‘L’ ‘M’ ‘Q’ ‘H’) | ‘L’ || includeMargin | boolean | false | 抽离分享组件 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from &apos;react&apos;;class Qrcode extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; shareTypes:[ &#123; image:&apos;//b-gold-cdn.xitu.io/v3/static/img/weibo.8e2f5d6.svg&apos;, text:&apos;微博&apos;, showQrcode:false, &#125;, &#123; image:&apos;//b-gold-cdn.xitu.io/v3/static/img/wechat.844402c.svg&apos;, text:&apos;微信扫一扫&apos;, showQrcode:true, &#125; ] &#125; &#125; render() &#123; const QRCode = require(&apos;qrcode.react&apos;); return ( &lt;ul&gt; &#123;this.state.shareTypes.map(item=&gt;&#123; return &lt;li key=&#123;item.text&#125; style=&#123;&#123;borderBottom:&apos;1px solid rgba(217,222,224,.99)&apos;,padding:&apos;10px&apos;,cursor:&apos;pointer&apos;&#125;&#125;&gt; &lt;div&gt; &lt;img alt=&#123;item.text&#125; src=&#123;item.image&#125; style=&#123;&#123;width:&apos;24px&apos;,height:&apos;24px&apos;,marginRight:&apos;5px&apos;&#125;&#125; /&gt; &lt;label style=&#123;&#123;color:&apos;#8f969c&apos;&#125;&#125;&gt;&#123;item.text&#125;&lt;/label&gt; &lt;/div&gt; &#123;item.showQrcode?&lt;div style=&#123;&#123;textAlign:&apos;center&apos;&#125;&#125;&gt; &lt;QRCode value=&#123;this.props.value&#125; /&gt; &lt;/div&gt;:&apos;&apos;&#125; &lt;/li&gt; &#125;)&#125; &lt;/ul&gt; ); &#125;&#125;export default Qrcode; 分享组件使用123456import Qrcode from &apos;../../components/Qrcode&apos;;...&lt;Popover content=&#123;&lt;Qrcode value=&#123;window.location.href+&apos;/&apos;+item.id&#125; /&gt;&#125; placement=&quot;bottom&quot; trigger=&quot;click&quot;&gt; &lt;Icon type=&quot;upload&quot; style=&#123;&#123; fontSize: &apos;16px&apos;,marginLeft:&apos;10px&apos;,borderRight:&apos;none&apos;&#125;&#125; onClick=&#123;()=&gt;this.props.shareArticle(item.id)&#125; /&gt; 分享&lt;/Popover&gt; 右侧卡片内容这块内容采用了ant-design中的card组件，直接看代码吧。 12345678910111213141516171819202122import &#123; Card &#125; from &apos;antd&apos;;...&lt;Card title=&quot;掘金优秀作者&quot; style=&#123;&#123; width: &apos;100%&apos; &#125;&#125; hoverable=&#123;&apos;true&apos;&#125; actions=&#123;[&lt;NavLink to=&apos;/recommendation/authors/recommended&apos; style=&#123;&#123;color:&apos;#007fff&apos;&#125;&#125;&gt;查看更多&gt;&lt;/NavLink&gt;]&#125; &gt; &lt;List itemLayout=&quot;horizontal&quot; dataSource=&#123;this.props.goodAuthor&#125; renderItem=&#123;item =&gt; ( &lt;List.Item onClick=&#123;()=&gt;window.location.href=&apos;/user/&apos;+item.id&#125;&gt; &lt;List.Item.Meta avatar=&#123;&lt;Avatar size=&#123;46&#125; src=&#123;item.userImage&#125; /&gt;&#125; title=&#123;item.title&#125; description=&#123;&lt;div className=&quot;overflow-ellipsis&quot;&gt;&#123;item.desc&#125;&lt;/div&gt;&#125; /&gt; &lt;/List.Item&gt; )&#125; /&gt;&lt;/Card&gt; goodAuthor数据是从父级传入的数据哈。 这里的内容结构类似，外层card组件，内置不同不同内容，就不重复了，想看具体实现的话请移步github,不要忘了star哈。 card内部使用list组件，竖着排列各自的内容，这一块总觉得可以抽成一个公用的card组件，然后填充不同内容，暂时就先这样吧，列入后期重构计划！这时就怀念vue中的slot方法了，可以方便的放置不同内容。jsx也有自己的方便之处吧，灵活的使用各种标签。 以上就是首页的一个简单说明了，页面大部分的链接router跳转功能还没有实现，后续陆续更新中。 想看第一篇文章的朋友可以查看使用React构建精简版本掘金（一）,上述所有详细代码都已经放到github了，欢迎浏览和star哈，都已经看到这里了，那就麻烦大家点个赞在走吧！ 既然没有合适的坑，那就趁着闲暇，继续提升自己的能力吧！最后鼓励下自己：扛过了艰难的时光，回头看，那也就不是什么大不了的事情了！]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用React构建精简版本掘金（一）]]></title>
    <url>%2F2019%2F03%2F19%2Freact-juejin%2F</url>
    <content type="text"><![CDATA[最近正在学习react，就想着能不能用react做一个项目，平时浏览掘金，就拿掘金练手吧！ 是不是可以以假乱真呢！😂😂😂 初始化 使用create-react-app初始化项目结构 1yarn create react-app react-juejin 这个脚手架会自动帮助我们搭建基础工程，同时安装React项目的各种必要依赖，如果在过程中出现网络问题，请尝试配置代理或使用其他 npm registry。进入项目并启动 12cd react-juejinyarn start 安装ant-design 1yarn add antd 配置UI库懒加载样式需要对整个项目重新配置，这里使用了react-app-rewired （一个对 create-react-app 进行自定义配置的社区解决方案）。1yarn add react-app-rewired customize-cra 修改package.json 文件如下 在根目录中创建config-overrides.js，用于重写覆盖默认的配置 1234module.exports = function override(config, env) &#123; // do stuff with the webpack config... return config;&#125;; 使用 babel-plugin-import该插件用于按需加载plugins和样式 1yarn add babel-plugin-import 修改上步创建的config-overrides.js 123456789const &#123; override, fixBabelImports &#125; = require(&apos;customize-cra&apos;);module.exports = override( fixBabelImports(&apos;import&apos;, &#123; libraryName: &apos;antd&apos;, libraryDirectory: &apos;es&apos;, style: &apos;css&apos;, &#125;)); 添加less-loader个人习惯使用less，看个人喜好安装即可，不过查阅上面社区方案react-app-rewired，并没有提供比如sass的重写方案，故如果需要使用sass，可采用别的方案引入。 1yarn add less less-loader 修改config-overrides.js 12345678910111213//const &#123; override, fixBabelImports &#125; = require(&apos;customize-cra&apos;);const &#123; override, fixBabelImports, addLessLoader &#125; = require(&apos;customize-cra&apos;);module.exports = override( fixBabelImports(&apos;import&apos;, &#123; libraryName: &apos;antd&apos;, libraryDirectory: &apos;es&apos;, style: true, &#125;), addLessLoader(&#123; javascriptEnabled: true, &#125;),); 以上详细配置的话可参考ant-design官网 引入redux 安装 1yarn add redux react-redux --save 使用方式考虑到之后可能会有多个reducer，开始就把结构弄好，做成日后可以方便合并使用多个reducer的方式（1）创建一个reducer 123456789101112131415161718// 建议使用这中结构// 1.定义默认数据let initialState = &#123; notificationCount: 0&#125;// 2.Reducerconst pageHeaderReducer = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case &apos;CHANGE_COUNT&apos;: return &#123; ...state, notificationCount: action.notificationCount &#125; default: return state &#125;&#125;// 3.导出export default pageHeaderReducer; （2）创建index.js,作为合并所有reducer的文件。 12345678import &#123;combineReducers&#125; from &apos;redux&apos;;import pageHeaderReducer from &apos;./pageHeader.js&apos;;const appReducer = combineReducers(&#123; pageHeaderReducer&#125;);export default appReducer; （3）App.js中使用定义好的reducer 1234567891011121314151617181920import &#123; createStore &#125; from &apos;redux&apos;import &#123; Provider &#125; from &apos;react-redux&apos;import appReducer from &apos;./reducers/index.js&apos;;// 使用合并后的那个Reducerconst store = createStore(appReducer);class App extends Component &#123; constructor(props)&#123; super(props); &#125; ... render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;div className=&quot;App&quot;&gt; ... &lt;/div&gt; &lt;/Provider&gt; ); &#125;&#125; (4)在header/index.js中使用redux 12345678910111213141516171819202122232425262728import &#123; connect &#125; from &apos;react-redux&apos;;class Header extends Component &#123; ... render() &#123; ... return ( &lt;Affix offsetTop=&#123;this.state.top&#125;&gt; ... &lt;Badge count=&#123;this.props.count&#125; overflowCount=&#123;10&#125;&gt; &lt;a href=&quot;/&quot;&gt; &lt;Icon type=&quot;notification&quot; /&gt; &lt;/a&gt; &lt;/Badge&gt; &lt;/Affix&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; count: state.pageHeaderReducer.notificationCount &#125;&#125;Header=connect(mapStateToProps)(Header)export default Header; 到目前为止，就可以在外部修改notificationCount的值，通过redux，组件内部就可以正常获取到对应的count值。更详细的redux配置可以参考redux中文文档 添加路由react-router首页导航中存在5个tab切换，分别对应这不同的页面内容。接下来介绍如何通过react-router实现不同页面内容的跳转。 安装react-router 1yarn add react-router-dom --save 使用方式 12345678910111213141516171819202122import &#123; Switch, Route &#125; from &apos;react-router-dom&apos;;...class Main extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;Switch&gt; &lt;Route exact path=&apos;/&apos; component=&#123;Home&#125;/&gt; &lt;Route path=&apos;/timeline&apos; component=&#123;Home&#125;/&gt; &lt;Route path=&apos;/dynamic&apos; component=&#123;Dynamic&#125;/&gt; &lt;Route path=&apos;/topic&apos; component=&#123;Topic&#125;/&gt; &lt;Route path=&apos;/brochure&apos; component=&#123;Brochure&#125;/&gt; &lt;Route path=&apos;/activity&apos; component=&#123;Activity&#125;/&gt; &lt;/Switch&gt; &lt;/div&gt; ); &#125;&#125; 上面的exact表示绝对匹配/,如果不注明exact,则/还会匹配/timeline等等上面代码实现了一个类似tabbar切换的效果 tab导航 1234567891011render() &#123; return ( &lt;ul&gt; &#123;this.state.navs.map((item,index)=&gt;&#123; return &lt;li key=&#123;item.path&#125; className=&#123;item.isActived?&apos;activeLi&apos;:&apos;&apos;&#125; onClick=&#123;this.handelClick.bind(this,index)&#125;&gt; &lt;Link to=&#123;item.path&#125;&gt;&#123;item.text&#125;&lt;/Link&gt; &lt;/li&gt; &#125;)&#125; &lt;/ul&gt; ); &#125; react-router中提供了Link和NavLik两种方式，如果仅仅需要匹配路由,使用Link就可以了,而NavLink的不同在于可以给当前选中的路由添加样式, 比如上面写到的activeStyle和activeClassName更详细的react-router配置可以参考React-router中文文档 到目前为止，基础结构就算是完成了，后续的就需要往各个页面添加实际内容了。 目前效果图如上所示，后续不断更新中。以上详细代码见github,欢迎点赞，您的点赞是我的动力。]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ant-design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[taro多端实践初探]]></title>
    <url>%2F2019%2F03%2F07%2Ftaroapp%2F</url>
    <content type="text"><![CDATA[历史的发展，小程序风行一时，安卓/ios/H5/微信小程序/支付宝小程序/头条小程序，产品经理让你适配这么多，你的心情如何呢？然而总会有人给咱们造出合适的工具，解放生产力，一次编码，多端运行。开始探索之旅吧！ taro安装安装 Taro 开发工具 @tarojs/cli使用 npm 或者 yarn 全局安装，或者直接使用npx 12$ npm install -g @tarojs/cli$ yarn global add @tarojs/cli 使用命令创建模版1$ taro init multiportApp 按照自己情况选择安装即可 启动进入对应目录，执行命令启动。 1npm run dev:h5 会出现启动成功的界面，如下 自动就会打开浏览器，出现hello world界面，表示项目启动成功了！ todolist功能实现添加数据在pages/index/index.js文件中添加如下1234567891011121314151617181920constructor(props)&#123; super(props); this.state=&#123; val:&apos;&apos;, todos:[ &#123; title:&apos;吃饭&apos;, done:false &#125;, &#123; title:&apos;睡觉&apos;, done:false &#125;, &#123; title:&apos;coding&apos;, done:false &#125; ] &#125; &#125; 渲染数据123456789101112render () &#123; return ( &lt;View className=&apos;index&apos;&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &#123; this.state.todos.map((item,index)=&gt;&#123; return &lt;View key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/View&gt; &#125;) &#125; &lt;/View&gt; ) &#125; 列表渲染搞定。 添加输入框和按钮引入组件1import &#123; View, Text,Input,Button &#125; from &apos;@tarojs/components&apos; render修改 1234567891011121314render () &#123; return ( &lt;View className=&apos;index&apos;&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &lt;Input value=&#123;this.state.val&#125; onInput=&#123;this.handleInput&#125;&gt;&lt;/Input&gt; &lt;Button onClick=&#123;this.handleClick&#125;&gt;添加&lt;/Button&gt; &#123; this.state.todos.map((item,index)=&gt;&#123; return &lt;View key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/View&gt; &#125;) &#125; &lt;/View&gt; ) &#125; 添加方法 123456789101112handleInput=(e)=&gt;&#123; this.setState(&#123; val:e.detail.value &#125;)&#125;handleClick=()=&gt;&#123; this.setState(&#123; todos:[...this.state.todos,&#123;title:this.state.val,done:false&#125;], val:&apos;&apos; &#125;)&#125; 一个简单的todolist就算完成了，界面有点丑，继续优化！ 优化，引入UI库安装taro-ui官网1npm install --save taro-ui 简单配置由于引用 node_modules 的模块，默认不会编译，所以需要额外给 H5 配置 esnextModules，在 taro 项目的 config/index.js 中新增如下配置项： 123h5: &#123; esnextModules: [&apos;taro-ui&apos;]&#125; 全局引入在app.scss中引入 1@import &apos;taro-ui/dist/style/index.scss&apos; 在index.js中引入 1import &#123; AtList, AtListItem &#125; from &quot;taro-ui&quot; 修改render 12345678910111213141516render () &#123; return ( &lt;View className=&apos;index&apos;&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &lt;Input value=&#123;this.state.val&#125; onInput=&#123;this.handleInput&#125;&gt;&lt;/Input&gt; &lt;Button onClick=&#123;this.handleClick&#125;&gt;添加&lt;/Button&gt; &lt;AtList&gt; &#123; this.state.todos.map((item,index)=&gt;&#123; return &lt;AtListItem key=&#123;index&#125; title=&#123;item.title&#125;&gt;&lt;/AtListItem&gt; &#125;) &#125; &lt;/AtList&gt; &lt;/View&gt; ) &#125; 添加滑块开关，改变item状态1&lt;AtListItem key=&#123;index&#125; title=&#123;item.title&#125; className=&#123;&#123;&apos;done&apos;:item.done&#125;&#125; isSwitch switchIsCheck=&#123;item.done&#125; onSwitchChange=&#123;(e)=&gt;this.handleChange(e,index)&#125;&gt;&lt;/AtListItem&gt; 增加一个isSwitch,switch切换事件，class。增加事件 12345678handleChange=(e,i)=&gt;&#123; console.log(e,i); const todos=[...this.state.todos]; todos[i].done=e.detail.value; this.setState(&#123; todos &#125;) &#125; 在同级目录下index.scss中增加样式 1234.done&#123; color: red; text-decoration: line-through;&#125; 效果h5效果微信小程序中的效果 这就是这个框架的威力，感谢taro开发团队。) 最后在说一句，正在找工作，坐标北京，各位大佬有合适的机会推荐下哈！]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>taro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvvm简易版本实现]]></title>
    <url>%2F2019%2F03%2F05%2Fmvvm%2F</url>
    <content type="text"><![CDATA[用了两年左右的vue，虽然看过vue的源码，推荐黄轶大佬的vue源码分析，相当到位。从头梳理了vue的实现过程。周末又看了一个公开课的vue源码分析，想着自己是不是也可以写一个来实现，说干就干，开始coding！目前最新版本的vue内部依然使用了Object.defineProperty()来实现对数据属性的劫持，进而达到监听数据变动的效果。 需要数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。 需要指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 mvvm入口函数，整合以上三者，实现数据响应。相信看过vue官网的小伙伴们一定看过下面这张图吧，解释了vue是如何实现响应式的数据绑定。 Observer类的实现主要利用了Object.defineProperty()这个方法，对数据进行遍历，给每一个对象都添加了getter()和setter().主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Observer&#123; constructor(data)&#123; this.data=data; this.traverse(data); &#125; traverse(data) &#123; var self = this; Object.keys(data).forEach(function(key) &#123; self.convert(key, data[key]); &#125;); &#125; convert(key,val)&#123; this.defineReactive(this.data, key, val); &#125; defineReactive(data, key, val) &#123; var dep = new Dep(); var childObj = observe(val); Object.defineProperty(data, key, &#123; enuselfrable: true, // 可枚举 configurable: false, // 不能再define get()&#123; if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); // 通知订阅者 dep.notify(); &#125; &#125;); &#125;&#125;function observe(value, vm) &#123; if (!value || typeof value !== &apos;object&apos;) &#123; return; &#125; return new Observer(value);&#125; 经过以上的方法，我们就劫持到了数据属性。 Compile类的实现主要用来解析各种指令，比如v-modal，v-on:click等指令。然后将模版中的变量替换成数据，渲染view，将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据发生变动，收到通知，更新视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186class Compile&#123; constructor(el,vm)&#123; this.$vm = vm; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125; &#125; node2Fragment(el)&#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125; init()&#123; this.compileElement(this.$fragment); &#125; compileElement(el)&#123; var childNodes = el.childNodes, self = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; if (self.isElementNode(node)) &#123; self.compile(node); &#125; else if (self.isTextNode(node) &amp;&amp; reg.test(text)) &#123; self.compileText(node, RegExp.$1); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; self.compileElement(node); &#125; &#125;); &#125; compile(node)&#123; var nodeAttrs = node.attributes, self = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; var attrName = attr.name; if (self.isDirective(attrName)) &#123; var exp = attr.value; var dir = attrName.substring(2); // 事件指令 if (self.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, self.$vm, exp, dir); // 普通指令 &#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, self.$vm, exp); &#125; node.removeAttribute(attrName); &#125; &#125;); &#125; compileText(node, exp)&#123; compileUtil.text(node, this.$vm, exp); &#125; isDirective(attr)&#123; return attr.indexOf(&apos;v-&apos;) == 0; &#125; isEventDirective(dir)&#123; return dir.indexOf(&apos;on&apos;) === 0; &#125; isElementNode(node)&#123; return node.nodeType == 1; &#125; isTextNode(node)&#123; return node.nodeType == 3; &#125;&#125;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, &apos;text&apos;); &#125;, html: function(node, vm, exp) &#123; this.bind(node, vm, exp, &apos;html&apos;); &#125;, model: function(node, vm, exp) &#123; this.bind(node, vm, exp, &apos;model&apos;); var self = this, val = this._getVMVal(vm, exp); node.addEventListener(&apos;input&apos;, function(e) &#123; var newValue = e.target.value; if (val === newValue) &#123; return; &#125; self._setVMVal(vm, exp, newValue); val = newValue; &#125;); &#125;, class: function(node, vm, exp) &#123; this.bind(node, vm, exp, &apos;class&apos;); &#125;, bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + &apos;Updater&apos;]; updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); new Watcher(vm, exp, function(value, oldValue) &#123; updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, // 事件处理 eventHandler: function(node, vm, exp, dir) &#123; var eventType = dir.split(&apos;:&apos;)[1], fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; if (eventType &amp;&amp; fn) &#123; node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, _getVMVal: function(vm, exp) &#123; var val = vm; exp = exp.split(&apos;.&apos;); exp.forEach(function(k) &#123; val = val[k]; &#125;); return val; &#125;, _setVMVal: function(vm, exp, value) &#123; var val = vm; exp = exp.split(&apos;.&apos;); exp.forEach(function(k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k]; &#125; else &#123; val[k] = value; &#125; &#125;); &#125;&#125;;var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value; &#125;, htmlUpdater: function(node, value) &#123; node.innerHTML = typeof value == &apos;undefined&apos; ? &apos;&apos; : value; &#125;, classUpdater: function(node, value, oldValue) &#123; var className = node.className; className = className.replace(oldValue, &apos;&apos;).replace(/\s$/, &apos;&apos;); var space = className &amp;&amp; String(value) ? &apos; &apos; : &apos;&apos;; node.className = className + space + value; &#125;, modelUpdater: function(node, value, oldValue) &#123; node.value = typeof value == &apos;undefined&apos; ? &apos;&apos; : value; &#125;&#125;; Watcher类的实现作为链接的桥梁，链接了compile和observer。添加订阅者，当检测到属性发生变化，接收到dep.notify()的通知的时候，就执行自身的update()方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Watcher&#123; constructor(vm, expOrFn, cb)&#123; this.cb = cb; this.vm = vm; this.expOrFn = expOrFn; this.depIds = &#123;&#125;; if (typeof expOrFn === &apos;function&apos;) &#123; this.getter = expOrFn; &#125; else &#123; this.getter = this.parseGetter(expOrFn); &#125; this.value = this.get(); &#125; update()&#123; this.run(); &#125; run()&#123; var value = this.get(); var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); &#125; &#125; addDep(dep)&#123; if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125; get() &#123; Dep.target = this; var value = this.getter.call(this.vm, this.vm); Dep.target = null; return value; &#125; parseGetter(exp)&#123; if (/[^\w.$]/.test(exp)) return; var exps = exp.split(&apos;.&apos;); return function(obj) &#123; for (var i = 0, len = exps.length; i &lt; len; i++) &#123; if (!obj) return; obj = obj[exps[i]]; &#125; return obj; &#125; &#125;&#125; mvvm实现MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化，触发视图更新；视图交互变化(input) 触发数据model变更的双向绑定效果。 123456789101112131415161718192021222324252627282930class Mvvm&#123; constructor(options)&#123; this.$options=options; this.data=this._data = this.$options.data; console.log(this.$options) var self = this; // 数据代理,实现响应，vue3会改写，使用proxy代理方式 Object.keys(this.data).forEach(function(key) &#123; self.defineReactive(key); &#125;); this.initComputed(); new Observer(this.data, this); this.$compile = new Compile(this.$options.el || document.body, this) &#125; defineReactive(key)&#123; var self=this; Object.defineProperty(this,key,&#123; configurable:false, enuselfrable:true, get()&#123; return self.data[key]; &#125;, set(newValue)&#123; self.data[key]=newValue; &#125; &#125;) &#125;&#125; 基本上就大功告成了，大部分代码都是参考了vue源码的实现，学着读源码吧，体会vue设计的优雅。顺便推荐一个github读源码的chrome插件：octotree.本文完整代码请查看github 本文同步发表于掘金/segmentfault 顺便说一句，最近开始找工作了，坐标北京，如果各位大佬有机会，望推荐下哈，在此先行谢过！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.0配置记录（2）]]></title>
    <url>%2F2019%2F02%2F02%2FwebpackConfig2%2F</url>
    <content type="text"><![CDATA[接上一篇webpack4.0配置记录(1),继续记录学习webpack配置。 定义环境变量1234new Webpack.DefinePlugin(&#123;//用来定义全局环境变量 DEV:JSON.stringify(&apos;dev&apos;), FLAG:&apos;true&apos;&#125;), webpack简单优化 noParse 123module:&#123; noParse:&apos;/jquery/&apos;,//不去解析设置的包所依赖的关系,如jquery&#125; ignorePlugin 12345678910111213141516171819module:&#123; noParse:&apos;/jquery/&apos;,//不去解析设置的包所依赖的关系 rules:[ &#123; test:/\.js$/, exclude:/node_modules/, include:path.resolve(&apos;src&apos;), use:&#123; loader:&apos;babel-loader&apos;, options:&#123; presets:[ &apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos; ] &#125; &#125; &#125; ]&#125; 通过exclude排除和include包含某些模块另外也可以使用webpack自带的ignorePlugin插件排除某些包，减少体积。 1new webpack.IgnorePlugin(/\.\/locale/,/moment/), 以上配置忽略了时间格式化moment.js中的语言包 happypack多线程打包 12345678910111213141516171819202122232425262728293031323334353637383940let Happypack=require(&apos;happypack&apos;)...module.exports=&#123; module:&#123; noParse:&apos;/jquery/&apos;,//不去解析设置的包所依赖的关系 rules:[ &#123; test:/\.js$/, exclude:/node_modules/, include:path.resolve(&apos;src&apos;), use:&apos;Happypack/loader?id=js&apos; // use:&#123; // loader:&apos;babel-loader&apos;, // options:&#123; // presets:[ // &apos;@babel/preset-env&apos;, // &apos;@babel/preset-react&apos; // ] // &#125; // &#125; &#125; ] &#125;, plugins:[ new Happypack(&#123; id:&apos;js&apos;, use:[ &#123; loader:&apos;babel-loader&apos;, options:&#123; presets:[ &apos;@babel/preset-env&apos;, &apos;@babel/preset-react&apos; ] &#125; &#125; ] &#125;) ]&#125; webpack内置功能(1)tree-shaking(2)scope-hosting这两项优化只在生产环境下有效 抽离公共代码 1234567891011121314151617181920module.exports=&#123; optimization:&#123; splitChunks:&#123;//分割代码块 cacheGroups:&#123;//缓冲组 common:&#123; chunks:&apos;initial&apos;, minSize:0,//抽离模块最小粒度是0 minChunks:2//表示代码块用过2次以上就要抽离 &#125;, vendor:&#123; priority:1,//相当于权重，先抽离第三方模块，如果不设置该属性，分割代码块将从上到下，无法抽离第三方模块。 test:/node_modules/, chunks:&apos;initial&apos;, minSize:0,//抽离模块最小是0 minChunks:2//表示用过2次以上就要抽离 &#125; &#125; &#125; &#125;,&#125; 文件热更新 1234567devServer:&#123; hot:true&#125;,plugins:[ new webpack.NamedModulesPlugin(),//打印更新的模块路径 new webpack.HotModuleReplacementPlugin()//热更新] 7.可以使用dllPlugin动态链接库优化DllPlugin 和 DllReferencePlugin提供了以大幅度提高构建时间性能的方式拆分软件包的方法。原理是将特定的第三方NPM包模块提前构建，然后通过页面引入。这不仅能够使得vendor文件可以大幅度减小，同时，也极大的提高了构件速度。网上别的大神有一篇文章写的很详细，可以参考，传送门。 以上就是一些自己在学习webpack4.0配置过程中的一些学习记录，写出来和大家分享，如果有错误，还望告知。欢迎关注交流！不要忘了点个赞，谢谢！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.0配置记录（1）]]></title>
    <url>%2F2019%2F02%2F01%2FwebpackConfig1%2F</url>
    <content type="text"><![CDATA[趁着假期闲暇，练习下webpack4.0的一些配置。 webpack4优化压缩js和css方式123456789101112let UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);let OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);optimization: &#123;//优化项 minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true,//并发打包 sourceMap: true // set to true if you want JS source maps &#125;),//开发环境下不压缩js，想启用压缩功能，需要把mode切换为production new OptimizeCSSAssetsPlugin(&#123;&#125;) ]&#125;, 注意：若想优化生效，必须将mode改为production模式详情见npm官网 expose-loader 暴露全局loader，称为内联loader。到目前为止，有内联loader，普通normal loader，前置loader (pre loader)，后置loader （post loader） 在项目中引入jquery类似模块方式webpack.config.js配置 123456let webpack =require(&apos;webpack&apos;);plugins:[//存放webpack插件 new webpack.ProvidePlugin(&#123;//在每个模块中注入$ &apos;$&apos;:&apos;jquery&apos; &#125;)], webpack引入基层模块方式 expose-loader暴露到全局window上 providePlugin给每个模块提供$ cdn方式引入不打包，webpack需要配置externals 打包文件分类123new MiniCssExtractPlugin(&#123; filename:&apos;css/main.css&apos;&#125;), 将css打包在css文件夹中 1234567891011&#123; test:/(.png|.jpg)$/, use:&#123; loader:&apos;url-loader&apos;, options:&#123; limit:50*1024, outputPath:&apos;images/&apos;, //publicPath:&apos;&apos; &#125; &#125;&#125; 图片打包路径前配置publicPath即可。 生成source-map便于调试，几种不同选项(1)增加源码映射文件，便于调试。标示报错文件行和列，大而全文件1devtool:&apos;source-map&apos; (2)不会产生单独文件，但是可以显示行和列1devtool:&apos;eval-source-map&apos; (3)不会产生列，但是是一个单独的映射文件，用于调试1devtool:&apos;cheap-module-source-map&apos; (4)不会产生文件，集成在打包后的文件中，也不会产生列1devtool:&apos;cheap-module-eval-source-map&apos; 监听文件变动，实时打包123456watch:true,watchOptions:&#123;//监听选项 poll:1000,//每秒问我1000次，是否打包 aggregateTimeout:500,//防抖 ignored:/node_modules///不需要监控的文件&#125;, webpack插件应用 cleanWebpackPlugin(需要安装依赖模块) 1new CleanWebpackPlugin(&apos;./dist&apos;)//先清空dist目录下的文件在打包 copyWebpackPlugin(需要安装依赖模块) 123456new CopyWebpackPlugin([ &#123; from:&apos;./doc&apos;, to:&apos;./dist&apos; &#125;//可以写多个，拷贝多个目录文件]) bannerPlugin(内置插件) 12//添加版权注释信息new Webpack.BannerPlugin(&apos;make by mgl 2019-2-1&apos;) 运行打包命令后，可在打包文件中看到注释信息 1npm run dev webpack中devServer几种配置(1)单纯配置跨域代理方式123456proxy:&#123; &apos;/api&apos;:&#123; target:&apos;http://localhost:3000&apos;, pathRewrite:&#123;&apos;/api&apos;:&apos;&apos;&#125; &#125;&#125; (2)前端单纯mock数据12345before(app)&#123; app.get(&apos;/user&apos;,(req,res)=&gt;&#123; res.json(&#123;name:&apos;mgl-before&apos;&#125;); &#125;)&#125; (3)有服务端，不用代理来处理，在服务端中启动webpack，用服务端端口12345678910111213141516171819//expresslet express = require(&apos;express&apos;);let webpack=require(&apos;webpack&apos;);//引入中间件let middle=require(&apos;webpack-dev-middleware&apos;);let config=require(&apos;./webpack.config.js&apos;);let compiler=webpack(config);//webpack处理返回结果let app=express();app.use(middle(compiler));app.get(&apos;/user&apos;,(req,res)=&gt;&#123; res.json(&#123;name:&apos;mgl&apos;&#125;);&#125;)app.listen(3000) resolve属性配置123456789resolve:&#123;//解析第三方模块 modules:[path.resolve(&apos;node_modules&apos;)], extensions:[&apos;.js&apos;,&apos;.css&apos;,&apos;.vue&apos;,&apos;.json&apos;]//指定解析后缀名称，从左向右 // mainFields:[&apos;style&apos;,&apos;main&apos;]//指定引入模块的先后顺序 // mainFiles:[],//指定入口文件的名字，默认是index.js // alias:&#123;//配置别名 // bootstrap:&apos;bootstrap/dist/css/bootstrap.css&apos; // &#125;&#125;, 陆续更新中，欢迎关注！]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端加密那点事]]></title>
    <url>%2F2019%2F01%2F21%2FfeEncrypt%2F</url>
    <content type="text"><![CDATA[前奏最近公司一个项目在传输数据的时候，测试部门安全扫描后，发现密码类型的数据是明文传输的，果断不符合要求，让加密，就有了接下来的故事。 使用场景前后端使用HTTP协议进行交互的时候，由于HTTP报文为明文，所以通常情况下对于比较敏感的信息可以通过加密在前端加密，然后在后端解密实现”混淆”的效果，避免在传输过程中敏感信息的泄露（如，密码，证件信息等）。不过前端加密只能保证传输过程中信息是‘混淆’过的，对于高手来说，打个debugger，照样可以获取到数据，并不安全，所谓的前端加密只是稍微增加了攻击者的成本，并不能保证真正的安全。综上，服务端绝对不能相信前端传递过来的密文直接保存入库，只能通过服务端自己加密进行加密保存。那么前端加密是不是就没有意义了呢？答案是否定的，至少可以保证传输过程中不是明文传输，如果前后端交互需要安全的通道建议使用HTTPS协议进行通信。 分类简单来说，加密分两种方式 对称加密对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密也就是密钥也可以用作解密密钥，这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，而且对计算机功能要求也没有那么高常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES 非对称加密非对称加密算法需要两个密钥：公钥（publickey）和私钥（privatekey）。 公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它方公开；得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公钥加密后的任何信息。常见的非对称加密算法有：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用） 对称加密DES实现方式(1)使用Crypto-JS通过DES算法在前端加密 1npm install crypto-js (2)加解密使用DES算法，工作方式为ECB，填充方式为PKcs7 123456789101112var CryptoJS = require(&quot;crypto-js&quot;);const secretKey = &apos;com.sevenlin.foo.key&apos;;var afterEncrypt = CryptoJS.DES.encrypt(&apos;encryptCode&apos;, CryptoJS.enc.Utf8.parse(secretKey), &#123; mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7&#125;).toString()console.log(afterEncrypt);//8/nZ2vZXxOzPhU7ZHBwz7w==var afterDecrypt = CryptoJS.DES.decrypt(afterEncrypt, CryptoJS.enc.Utf8.parse(secretKey), &#123; mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7&#125;).toString(CryptoJS.enc.Utf8);console.log(afterDecrypt);//encryptCode (3)使用BC通过DES算法在后端解密a.安装 12345&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk16&lt;/artifactId&gt; &lt;version&gt;1.46&lt;/version&gt;&lt;/dependency&gt; b.加解密工具 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class DesCipherUtil &#123; private DesCipherUtil() &#123; throw new AssertionError(&quot;No DesCipherUtil instances for you!&quot;); &#125; static &#123; // add BC provider Security.addProvider(new BouncyCastleProvider()); &#125; /** * 加密 * * @param encryptText 需要加密的信息 * @param key 加密密钥 * @return 加密后Base64编码的字符串 */ public static String encrypt(String encryptText, String key) &#123; if (encryptText == null || key == null) &#123; throw new IllegalArgumentException(&quot;encryptText or key must not be null&quot;); &#125; try &#123; DESKeySpec desKeySpec = new DESKeySpec(key.getBytes()); SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec); Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS7Padding&quot;, &quot;BC&quot;); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] bytes = cipher.doFinal(encryptText.getBytes(Charset.forName(&quot;UTF-8&quot;))); return Base64.getEncoder().encodeToString(bytes); &#125; catch (NoSuchAlgorithmException | InvalidKeyException | InvalidKeySpecException | NoSuchPaddingException | BadPaddingException | NoSuchProviderException | IllegalBlockSizeException e) &#123; throw new RuntimeException(&quot;encrypt failed&quot;, e); &#125; &#125; /** * 解密 * * @param decryptText 需要解密的信息 * @param key 解密密钥，经过Base64编码 * @return 解密后的字符串 */ public static String decrypt(String decryptText, String key) &#123; if (decryptText == null || key == null) &#123; throw new IllegalArgumentException(&quot;decryptText or key must not be null&quot;); &#125; try &#123; DESKeySpec desKeySpec = new DESKeySpec(key.getBytes()); SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec); Cipher cipher = Cipher.getInstance(&quot;DES/ECB/PKCS7Padding&quot;, &quot;BC&quot;); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] bytes = cipher.doFinal(Base64.getDecoder().decode(decryptText)); return new String(bytes, Charset.forName(&quot;UTF-8&quot;)); &#125; catch (NoSuchAlgorithmException | InvalidKeyException | InvalidKeySpecException | NoSuchPaddingException | BadPaddingException | NoSuchProviderException | IllegalBlockSizeException e) &#123; throw new RuntimeException(&quot;decrypt failed&quot;, e); &#125; &#125;&#125; c.解密前端的加密信息 1234String fromWeb = &quot;8/nZ2vZXxOzPhU7ZHBwz7w==&quot;;String key = &quot;com.sevenlin.foo.key&quot;;String afterDecrypt = DesCipherUtil.decrypt(fromWeb, key);System.out.println(afterDecrypt);//encryptCode 非对称加密(1)下载加密文件依赖(2) 引入依赖 1&lt;script src=&quot;bin/jsencrypt.min.js&quot;&gt;&lt;/script&gt; 或者 1import &apos;../../assets/js/jsencrypt.min.js&apos;; (3)使用方式12345678910111213141516171819202122232425262728this.privateKey=`-----BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQDlOJu6TyygqxfWT7eLtGDwajtNFOb9I5XRb6khyfD1Yt3YiCgQWMNW649887VGJiGr/L5i2osbl8C9+WJTeucF+S76xFxdU6jE0NQ+Z+zEdhUTooNRaY5nZiu5PgDB0ED/ZKBUSLKL7eibMxZtMlUDHjm4gwQco1KRMDSmXSMkDwIDAQABAoGAfY9LpnuWK5Bs50UVep5c93SJdUi82u7yMx4iHFMc/Z2hfenfYEzu+57fI4fvxTQ//5DbzRR/XKb8ulNv6+CHyPF31xk7YOBfkGI8qjLoq06V+FyBfDSwL8KbLyeHm7KUZnLNQbk8yGLzB3iYKkRHlmUanQGaNMIJziWOkN+N9dECQQD0ONYRNZeuM8zd8XJTSdcIX4a3gy3GGCJxOzv16XHxD03GW6UNLmfPwenKu+cdrQeaqEixrCejXdAFz/7+BSMpAkEA8EaSOeP5Xr3ZrbiKzi6TGMwHMvC7HdJxaBJbVRfApFrE0/mPwmP5rN7QwjrMY+0+AbXcm8mRQyQ1+IGEembsdwJBAN6az8Rv7QnD/YBvi52POIlRSSIMV7SwWvSK4WSMnGb1ZBbhgdg57DXaspcwHsFV7hByQ5BvMtIduHcT14ECfcECQATeaTgjFnqE/lQ22Rk0eGaYO80cc643BXVGafNfd9fcvwBMnk0iGX0XRsOozVt5AzilpsLBYuApa66NcVHJpCECQQDTjI2AQhFc1yRnCU/YgDnSpJVm1nASoRUnU8Jfm3Ozuku7JUXcVpt08DFSceCEX9unCuMcT72rAQlLpdZir876-----END RSA PRIVATE KEY-----`; this.publicKye=`-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDlOJu6TyygqxfWT7eLtGDwajtNFOb9I5XRb6khyfD1Yt3YiCgQWMNW649887VGJiGr/L5i2osbl8C9+WJTeucF+S76xFxdU6jE0NQ+Z+zEdhUTooNRaY5nZiu5PgDB0ED/ZKBUSLKL7eibMxZtMlUDHjm4gwQco1KRMDSmXSMkDwIDAQAB-----END PUBLIC KEY-----`; var encrypt = new JSEncrypt(); encrypt.setPublicKey(this.publicKye); var encrypted = encrypt.encrypt(&apos;encryptCode&apos;);//w1a1FXmlbFj9yOxLCoqIzNo2ytXypyupZABsi/e4kMA9mERngmaDwlOuHsUDQKC0nK1v7Ehr3vYKcALFQvjscWEkGIW/UWCk73jArwqEYF1wd45eHSCPwUeB85Ellr+IYTqhZXcfmHZUCuprF2gayPUecq7F51aWxpfqMP0uvtY= // Decrypt with the private key... var decrypt = new JSEncrypt(); decrypt.setPrivateKey(this.privateKey); var uncrypted = decrypt.decrypt(encrypted);//encryptCode 生成publickey和privateKey的在线地址 虽然前端可以加密，终归不是安全方式，如果为了更加的安全还是使用https传输，后端加密保存吧！ 参考文章：通过DES实现JavaScript加密和Java解密加密库]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>‘加密’</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack打包性能优化之路]]></title>
    <url>%2F2019%2F01%2F12%2Fprojectoptimize%2F</url>
    <content type="text"><![CDATA[性能优化的路没有穷尽，只有更快。打开页面越快越好，点击响应越快越好。在当今这个以快为主的时代，快才是王道。闲话扯完，说正事！！！ 该优化方案以最近做的一个hybrid webapp为实例演示。 路由懒加载（1）vue-router文件中的router使用懒加载方式。如下图所示 （2）在vue文件中，也采用类似方式引入其他vue组件 1const showImage = () =&gt; import(&apos;@/components/common/showImage&apos;); 这个优化的方式在vue官网也有介绍，传送门 启用gzip压缩和关闭sourcemap所有现代浏览器都支持 gzip 压缩并会为所有 HTTP 请求自动协商此类压缩。启用 gzip 压缩可大幅缩减所传输的响应的大小（最多可缩减90%），从而显著缩短下载相应资源所需的时间、减少客户端的流量消耗并加快网页的首次呈现速度。 如下图所示 如果你使用的是vue-cli2生成的项目的话，在config文件夹下的index.js中可以找到这段代码。记得开启gzip压缩前要安装一个插件，如途中注释掉的一段代码所示。 生产环境去掉console代码，减少代码体积，使用uglifyjs压缩代码 图片优化对于网页来说，在所下载的字节数中，图片往往会占很大比例。因此，优化图片通常可以卓有成效地减少字节数和改进性能：浏览器需要下载的字节数越少，对客户端带宽的争用就越少，浏览器下载内容并在屏幕上呈现内容的速度就越快。尽量减少图片的使用，或者使用css3来代替图片效果。如果不行的话，小图片通过一定的工具合成雪碧图或者转成base64。 引用的库尽量按需加载。(1)像一般的ui库element，vant等库都提供来按需加载的方式，避免全部引入，加大项目体积。(2)以cdn方式载入需要的库，也可以减少打包后的体积。在index.html文件中 引入mintui1234&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/mint-ui/lib/style.css&quot;&gt;&lt;!-- 引入组件库 --&gt;&lt;script src=&quot;https://unpkg.com/mint-ui/lib/index.js&quot;&gt;&lt;/script&gt; 引入vue 1234&lt;!-- 开发环境使用此方案--&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 生产环境使用此方案 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js&quot;&gt;&lt;/script&gt; 以这种外链方式引入mint-ui和vue后，需要做些别的配置（1）在入口文件main.js 中就不需要引入vue和mintui了（2）在build\webpack.base.conf.js中添加如下配置，意为打包的时候不打包vue和mint-ui。 1234externals:&#123; &quot;mint-ui&quot;:&quot;mintui&quot;, &quot;vue&quot;:&quot;Vue&quot;&#125;, 使用DllReferencePlugin将平时不经常变动的文件抽离出来，统一打包，这样也可以减少后续打包的时间。 在build文件夹中新建一个webpack.dll.conf.js. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)module.exports = &#123; mode: process.env.NODE_ENV === &apos;production&apos; ? &apos;production&apos; : &apos;development&apos;, entry: &#123; vendor: [ //根据实际情况添加 &apos;axios&apos;, &apos;vue/dist/vue.min.js&apos;, &apos;vue-router&apos;, &apos;vuex&apos;, &apos;mint-ui&apos; ] &#125;, output: &#123; path: path.resolve(__dirname, &apos;../static/js&apos;), filename: &apos;[name].dll.js&apos;, library: &apos;[name]_library&apos; &#125;, module: &#123; rules: [ &#123; test: /\.vue$/, loader: &apos;vue-loader&apos; &#125;, &#123; test: /\.js$/, loader: &apos;babel-loader&apos;, exclude: /node_modules\/(?!(autotrack|dom-utils))/ &#125; ] &#125;, optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: false // set to true if you want JS source maps &#125;), // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins: [ /* @desc: https://webpack.js.org/plugins/module-concatenation-plugin/ &quot;作用域提升(scope hoisting)&quot;,使代码体积更小[函数申明会产生大量代码](#webpack3) */ new webpack.optimize.ModuleConcatenationPlugin(), new webpack.DllPlugin(&#123; path: path.join(__dirname, &apos;.&apos;, &apos;[name]-manifest.json&apos;), name: &apos;[name]_library&apos; &#125;) ]&#125; 在package.json中增加配置 123&quot;scripts&quot;: &#123; &quot;build:dll&quot;: &quot;webpack -p --progress --config build/webpack.dll.conf.js&quot; &#125; 执行npm run build:dll命令就可以在根目录下生成vendor-manifest.json,static/js下生成vendor.dll.js 在webpack.base.conf.js中增加如下 12345678910const manifest = require(&apos;../vendor-manifest.json&apos;)....plugins: [ //把dll的vendor-manifest.json引用到需要的预编译的依赖 new webpack.DllReferencePlugin(&#123; manifest &#125;)] 在index.html底部添加 1&lt;script src=&quot;./static/js/vendor.dll.js&quot;&gt;&lt;/script&gt; 目前在项目中做的优化就是这些，还是那句话，性能优化的路没有穷尽，只有更快。 参考文章（1）https://blog.csdn.net/blueberry_liang/article/details/80320607（2）https://developers.google.com/speed/docs/insights/rules?csw=1（3）https://www.jeffjade.com/2017/03/11/120-how-to-write-vue-better/]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapp字号大小跟随系统字号大小缩放]]></title>
    <url>%2F2018%2F12%2F25%2FappPageFlexible%2F</url>
    <content type="text"><![CDATA[最近做了一个webapp项目，混合式开发，外部原生，内部webview嵌套H5页面。前端方面采用了vue开发，适配采用的是flexible+rem做的适配。本来一切都很好，可是吧，领导说客户有的年纪大 ，看不清字体，希望网页字体可以跟随系统字号大小变化。当时心里真是…，然无奈只能想办法解决问题，网上搜罗一圈都是禁止内部跟随系统字号变化，看来只能自己搞了。 第一种方案最简单的让原生进行操作，内部不做控制，外部放大，里面自己适应。但是有问题，文本字体可以放大，有的输入框和输入框的内容却没有放大，故淘汰该方案。 第二种方案外部原生webview让里面的放大缩小不跟随系统变化，内部自己控制。和安卓同事商量后，他去获取系统放大的参数，然后将参数传递给内部webapp，内部来自定义控制缩放。代码如下：12345678910111213141516171819setScaleFont()&#123; let fontScale=1; let scaleFontSize; let initFontSize; fontScale=parseFloat(window._nativeMe.getFontScale()); console.log(`缩放比例：$&#123;fontScale&#125;`); let docHtml=document.getElementsByTagName(&quot;html&quot;)[0]; initFontSize=this.getStyle(docHtml,&apos;fontSize&apos;).split(&apos;px&apos;)[0]; scaleFontSize=fontScale*initFontSize;//1-1.4等比缩放 docHtml.style.fontSize=scaleFontSize +&apos;px&apos;; &#125;, getStyle(obj, name)&#123; if(window.currentStyle)&#123; return obj.currentStyle[name]; &#125; else&#123; return getComputedStyle(obj, false)[name]; &#125; &#125; 先获取到初始的缩放比例，然后根据安卓原生传入的缩放比例改写html标签上的fontsize大小，由于采用了rem适配，自会根据根元素大小进行适配。这种方案必须确保先让flexible的适配先执行，然后判断是否是安卓，如果是安卓就执行setScaleFont方法才有效，否则会被flexible里面的方法覆盖掉，造成页面先放大后缩小或者先缩小后放大的现象。 如上图，我是注释掉了这段代码，不然就会产生上述放大缩小的现象。 结论该种方法也只能在安卓上有效，苹果由于安全权限的问题无法获取系统字体的缩放比例，故无法调整，如果有大神知道在苹果上如何操作或者有别的更好办法，请告知，不胜感激。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>Html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue移动端项目记录滚动位置方案总结]]></title>
    <url>%2F2018%2F11%2F20%2FvueAppRecordScroll%2F</url>
    <content type="text"><![CDATA[最近在用vue做移动端项目，列表展示页面有很多条数据，在滑动到下面的时候，点到对应详情页，此时后退，应该在之前滚动的位置，不能滚动到顶部，这就需要记录滚动位置。这是需求，说完了需求，就考虑怎么实现吧！ （1）利用vue内置组件keep-alive缓存页面在路由文件router.js中设置缓存，方式如下12345678&#123; path: &apos;/home&apos;, name: &apos;home&apos;, component: resolve =&gt; require([&apos;@/components/process/home&apos;], resolve), meta: &#123; keepAlive: true &#125;&#125; 这样的话，后退的时候就不会刷新页面，完成第一步。 （2）监听滚动条滚动位置给滚动元素父级设置一个别名ref值，比如叫scroll吧。 12let that=this;this.$refs.scroll.addEventListener(&quot;scroll&quot;,that.recordScrollPosition,true); //添加绑定事件 recordScrollPosition是一个方法，用于记录滚动位置。这里有一个需要注意的点，必须先把this对象存储一下，不然的话直接用this.recordScrollPosition是无法调用到recordScrollPosition，因为此时this指向的是当前dom节点，而不是vue实例，自然无法调用到methods里定义的方法，当时这个地方没注意，卡了好久。这个监听的动作要写在activated周期里，每次进入都要监听。 123456789activated()&#123; this.$refs.scroll.scrollTop = this.list_top; let that=this; this.$refs.scroll.addEventListener(&quot;scroll&quot;,that.recordScrollPosition,true); &#125;, deactivated()&#123; let that=this; this.$refs.scroll.removeEventListener(&quot;scroll&quot;,that.recordScrollPosition,true); &#125; 当然最后应该销毁监听。 （3）将滚动位置存储起来这里存储滚动位置的话可以将其存到localStorage里，也可以将其存到vuex里，这里我为了方便就把它存到vuex里了。 123recordScrollPosition(e) &#123; this.$store.dispatch(&quot;setListTop&quot;,e.target.scrollTop);//实时存入到vuex中&#125; (4)vuex里设置12345678910111213141516171819const state = &#123; top:0 //滚动条初始位置&#125;const mutations=&#123; setHomeListTop(state,top)&#123; state.top=top; &#125;&#125;const getters = &#123; list_top(state)&#123; return state.top; &#125;&#125;const actions = &#123; setListTop(&#123;commit,state&#125;,top)&#123; commit(&apos;setHomeListTop&apos;,top); &#125;&#125; 到此大功告成，详细的代码我写了一个demo，放到了github上。传送门]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue移动端项目缓存问题实践]]></title>
    <url>%2F2018%2F10%2F28%2FvueCatch%2F</url>
    <content type="text"><![CDATA[最近在做一个vue移动端项目，被缓存问题搞得头都大了，积累了一些经验，特此记录总结下，权当是最近项目问题的一个回顾吧！ 先描述下问题场景：A页面-&gt;B页面-&gt;C页面。假设A页面是列表页面，B页面是列表详情页面，C页面是操作改变B页面的一些东西，进行提交类似的操作。A页面进入B页面，应该根据不同的列表item显示不一样的详情，从B进入C，也应该根据item的标识比如ID展示不一样的内容，在C页面操作后，返回B页面，B页面数据发生变化。这个时候会有两种情况： C页面操作数据后返回B页面，B页面对应数据应该发生变化。 C页面直接点击左上角箭头返回，B页面对应数据不应该发生变化。继续返回A列表页面，换一条数据，继续进入B页面，B页面展示不同内容，进入C页面，C页面刷新展示不同内容 另一种情况发生在写邮件的页面中，添加收件人，选人之后，继续添加，之前添加的联系人应该存在。但是从写邮件页面返回邮件列表再次进入写邮件页面，之前添加过的联系人数据就不应该存在了，这里就涉及到如何处理缓存，何时使用缓存，何时清除缓存的问题了。 目前项目整体结构如下： 12345678&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 虽然官方提供了include，exclude，可以让我们决定哪些组件使用缓存，哪些不使用缓存，但是并没有解决我们想动态使用缓存的目的，目前我的项目使用了如下两种方式处理缓存： 方式一 ，使用是否使用缓存标识在路由文件router.js里给每个路由添加meta信息，标识是否使用缓存。 1234meta: &#123; isUseCache: false,//不使用缓存 keepAlive: true&#125; 使用方式：A-&gt;B，B不能缓存;B-&gt;A,A缓存。 （1）A页面： 123456789101112beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta if(to.path==&apos;/B&apos;)&#123; to.meta.isUseCache = false; &#125; next();&#125;,activated()&#123; if(!this.$route.meta.isUseCache)&#123; this.getData(); &#125;&#125; (2) B页面 123456789101112beforeRouteLeave(to, from, next) &#123; // 设置下一个路由的 meta if(to.path==&apos;/A&apos;)&#123; to.meta.isUseCache = true; &#125; next();&#125;,activated()&#123; if(!this.$route.meta.isUseCache)&#123; this.getData(); &#125;&#125; 方式二，强制清除缓存。这种方式是从网上找的一种方式，使用了vue内部组件之后，不在支持动态销毁组件，缓存一直存在，只能从源头上下手，清掉缓存。 123456789101112131415161718192021222324252627282930313233export const removeCatch = &#123; beforeRouteLeave:function(to, from, next)&#123; if (from &amp;&amp; from.meta.rank &amp;&amp; to.meta.rank &amp;&amp; from.meta.rank&gt;to.meta.rank) &#123;//此处判断是如果返回上一层，你可以根据自己的业务更改此处的判断逻辑，酌情决定是否摧毁本层缓存。 if (this.$vnode &amp;&amp; this.$vnode.data.keepAlive) &#123; if (this.$vnode.parent &amp;&amp; this.$vnode.parent.componentInstance &amp;&amp; this.$vnode.parent.componentInstance.cache) &#123; if (this.$vnode.componentOptions) &#123; var key = this.$vnode.key == null ? this.$vnode.componentOptions.Ctor.cid + (this.$vnode.componentOptions.tag ? `::$&#123;this.$vnode.componentOptions.tag&#125;` : &apos;&apos;) : this.$vnode.key; var cache = this.$vnode.parent.componentInstance.cache; var keys = this.$vnode.parent.componentInstance.keys; if (cache[key]) &#123; if (keys.length) &#123; var index = keys.indexOf(key); if (index &gt; -1) &#123; keys.splice(index, 1); &#125; &#125; delete cache[key]; &#125; &#125; &#125; &#125; this.$destroy(); &#125; next(); &#125;&#125;; 在需要清掉缓存的页面混合引入该js即可。原文链接 结语移动端的缓存真是麻烦啊，前进后退，什么时候使用缓存，什么时候不使用缓存，都需要经过仔细的处理，不然就会有想不到的问题。不过经过这次项目，也积累了一定的经验。如果有大佬有别的更好的解决办法，还请告知，多谢！还是那句话，有问题就去解决，不要害怕问题，解决了问题，你就会成长！]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery旋转动画]]></title>
    <url>%2F2018%2F09%2F20%2FjqueryAnimation%2F</url>
    <content type="text"><![CDATA[最近一个项目中用到一个小动画，特此记录下。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=”IE=Edge,chrome=1″ /&gt; &lt;title&gt;jquery小动画&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0; padding: 0; &#125; body&#123; background: #134f6d; &#125; .tyCon &#123; position: relative; width: 401px; height: 401px; margin: 0 auto; margin-top: 300px; &#125; .tyCon .ty &#123; width: 401px; height: 142px; border: 1px solid #fff; border-radius: 90%; opacity: 0; position: absolute; top: 0; left: 0; -webkit-transform-origin: 50% 50%; -ms-transform-origin: 50% 50%; transform-origin: 50% 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tyCon js-tyCon&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; var tyHtml=&apos;&apos;; var xzDeg=0; for(var i=0;i&lt;25;i++)&#123; tyHtml+=&apos;&lt;div class=&quot;ty&quot;&gt;&lt;/div&gt;&apos;; &#125; $(&quot;.js-tyCon&quot;).append(tyHtml); var n=0; var interval=setInterval(xz,100); function xz()&#123; if(n==25)&#123; clearInterval(interval); return &#125; xzDeg+=7.2; $(&quot;.js-tyCon .ty&quot;).eq(n).css(&#123;&quot;opacity&quot;:&quot;0.55&quot;,&quot;transform&quot;:&quot;rotate(&quot;+xzDeg+&quot;deg)&quot;&#125;); n++ &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用setInterval循环旋转椭圆。]]></content>
      <categories>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用函数集合整理]]></title>
    <url>%2F2018%2F09%2F11%2FusefulFunction%2F</url>
    <content type="text"><![CDATA[收集整理日常工作中会用到的一些常用函数 函数防抖12345678910111213141516171819202122232425262728/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */function debounce(func,wait,immediate) &#123; var timeout; return function () &#123; var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 时间戳转化成时间格式12345678910111213add0(m) &#123; return m &lt; 10 ? '0' + m : m;&#125;, formatDate(myTime) &#123; let time = new Date(myTime); var year = time.getFullYear(); var month = time.getMonth() + 1; var date = time.getDate(); var hours = time.getHours(); var minutes = time.getMinutes(); var seconds = time.getSeconds(); return year + '-' + this.add0(month) + '-' + this.add0(date) + ' ' + this.add0(hours) + ':' + this.add0(minutes); // + ':' + this.add0(seconds) &#125; 时间转成时间戳12345678var date = new Date('2014-04-23 18:55:49:123');// 有三种方式获取var time1 = date.getTime();var time2 = date.valueOf();var time3 = Date.parse(date);console.log(time1);//1398250549123console.log(time2);//1398250549123console.log(time3);//1398250549000 备注以上三种获取方式的区别： 第一、第二种：会精确到毫秒 第三种：只能精确到秒，毫秒用000替代 以上三个输出结果可观察其区别 注意：获取到的时间戳除以1000就可获得Unix时间戳，就可传值给后台得到。 固定范围随机数生成1234getRandom(x, y) &#123; let random = Math.round(Math.random() * (y - x) + x); return random;&#125; 函数节流12345678910111213141516171819202122232425262728293031/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */function throttle(func, wait ,type) &#123; if(type===1)&#123; var previous = 0; &#125;else if(type===2)&#123; var timeout; &#125; return function() &#123; var context = this; var args = arguments; if(type===1)&#123; var now = Date.now(); if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;else if(type===2)&#123; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125; &#125;&#125; 获取当前可视范围的高度123456789getClientHeight() &#123; var clientHeight = 0; if (document.body.clientHeight &amp;&amp; document.documentElement.clientHeight) &#123; clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight); &#125; else &#123; clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight); &#125; return clientHeight;&#125; 获取滚动条距离顶部高度123456789getScrollTop() &#123; var scrollTop = 0; if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123; scrollTop = document.documentElement.scrollTop; &#125; else if (document.body) &#123; scrollTop = document.body.scrollTop; &#125; return scrollTop;&#125; 获取文档完整高度123getScrollHeight() &#123; return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);&#125; 获取字符串长度（汉字算两个字符，字母数字算一个）12345678910111213function getByteLen(val) &#123; var len = 0; for (var i = 0; i &lt; val.length; i++) &#123; var a = val.charAt(i); if (a.match(/[^\x00-\xff]/ig) != null) &#123; len += 2; &#125; else &#123; len += 1; &#125; &#125; return len;&#125; 获取字符串字节长度123456789101112131415/** * 获取字符串字节长度 * @param &#123;String&#125; * @returns &#123;Boolean&#125; */function checkLength(v) &#123; var realLength = 0; var len = v.length; for (var i = 0; i &lt; len; i++) &#123; var charCode = v.charCodeAt(i); if (charCode &gt;= 0 &amp;&amp; charCode &lt;= 128) realLength += 1; else realLength += 2; &#125; return realLength;&#125; 限制字数1234567891011121314151617/* * 限制字数用, 一个汉字算一个字,两个英文/字母算一个字 */function getByteVal(val, max) &#123; var returnValue = ''; var byteValLen = 0; for (var i = 0; i &lt; val.length; i++) &#123; if (val[i].match(/[^\x00-\xff]/ig) != null) byteValLen += 1; else byteValLen += 0.5; if (byteValLen &gt; max) break; returnValue += val[i]; &#125; return returnValue;&#125; 限制字符数1234567891011121314151617/* * 限制字符数用, 一个汉字算两个字符,一个英文/字母算一个字符 */function getCharVal(val, max) &#123; var returnValue = ''; var byteValLen = 0; for (var i = 0; i &lt; val.length; i++) &#123; if (val[i].match(/[^\x00-\xff]/ig) != null) byteValLen += 2; else byteValLen += 1; if (byteValLen &gt; max) break; returnValue += val[i]; &#125; return returnValue;&#125; 判断数组中是否有重复值1234567891011// 判断数组中是否有重复值function isRepeat(arr)&#123; var hash = &#123;&#125;; for(var i in arr) &#123; if(hash[arr[i]])&#123; return true; &#125; hash[arr[i]] = true; &#125; return false;&#125; 截取指定字节的字符串1234567891011121314151617181920212223242526/** * 截取指定字节的字符串 * @param str 要截取的字符穿 * @param len 要截取的长度，根据字节计算 * @param suffix 截取前len个后，其余的字符的替换字符，一般用“…” * @returns &#123;*&#125; */function cutString(str, len, suffix) &#123; if (!str) return ""; if (len &lt;= 0) return ""; if (!suffix) suffix = ""; var templen = 0; for (var i = 0; i &lt; str.length; i++) &#123; if (str.charCodeAt(i) &gt; 255) &#123; templen += 2; &#125; else &#123; templen++ &#125; if (templen == len) &#123; return str.substring(0, i + 1) + suffix; &#125; else if (templen &gt; len) &#123; return str.substring(0, i) + suffix; &#125; &#125; return str;&#125; 判断是否是微信浏览器123456789101112/** * 判断微信浏览器 * @returns &#123;Boolean&#125; */function isWeiXin() &#123; var ua = window.navigator.userAgent.toLowerCase(); if (ua.match(/MicroMessenger/i) == 'micromessenger') &#123; return true; &#125; else &#123; return false; &#125;&#125; 获取时间格式的实例12345678910111213141516171819202122232425262728293031function getTimeFormat(time) &#123; var date = new Date(parseInt(time) * 1000); var month, day, hour, min; parseInt(date.getMonth()) + 1 &lt; 10 ? month = '0' + (parseInt(date.getMonth()) + 1) : month = parseInt(date.getMonth()) + 1; date.getDate() &lt; 10 ? day = '0' + date.getDate() : day = date.getDate(); date.getHours() &lt; 10 ? hour = '0' + date.getHours() : hour = date.getHours(); date.getMinutes() &lt; 10 ? min = '0' + date.getMinutes() : min = date.getMinutes(); return [month, day].join('-') + ' ' + hour + ':' + min&#125;function getTimeFormatYMD(time) &#123; var date = new Date(parseInt(time) * 1000); var year, month, day; year = date.getFullYear(); parseInt(date.getMonth()) + 1 &lt; 10 ? month = '0' + (parseInt(date.getMonth()) + 1) : month = parseInt(date.getMonth()) + 1; date.getDate() &lt; 10 ? day = '0' + date.getDate() : day = date.getDate(); return [year, month, day].join('-')&#125;function getTimeFormatAll(time) &#123; var date = new Date(parseInt(time) * 1000); var year, month, day, hour, min, second; year = date.getFullYear(); parseInt(date.getMonth()) + 1 &lt; 10 ? month = '0' + (parseInt(date.getMonth()) + 1) : month = parseInt(date.getMonth()) + 1; date.getDate() &lt; 10 ? day = '0' + date.getDate() : day = date.getDate(); date.getHours() &lt; 10 ? hour = '0' + date.getHours() : hour = date.getHours(); date.getMinutes() &lt; 10 ? min = '0' + date.getMinutes() : min = date.getMinutes(); date.getSeconds() &lt; 10 ? second = '0' + date.getSeconds() : second = date.getSeconds(); return [year, month, day].join('-') + ' ' + hour + ':' + min + ':' + second&#125; 对象的克隆和拷贝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 对象克隆&amp;深拷贝 * @param obj * @returns &#123;&#123;&#125;&#125; */function cloneObj(obj) &#123; var newO = &#123;&#125;; if (obj instanceof Array) &#123; newO = []; &#125; for (var key in obj) &#123; var val = obj[key]; newO[key] = typeof val === 'object' ? arguments.callee(val) : val; &#125; return newO;&#125;;//克隆拷贝增强版/** * 对象克隆&amp;深拷贝 * @param obj * @returns &#123;&#123;&#125;&#125; */function clone(obj) &#123; // Handle the 3 simple types, and null or undefined if (null == obj || "object" != typeof obj) return obj; // Handle Date if (obj instanceof Date) &#123; var copy = new Date(); copy.setTime(obj.getTime()); return copy; &#125; // Handle Array if (obj instanceof Array) &#123; var copy = []; for (var i = 0, len = obj.length; i &lt; len; ++i) &#123; copy[i] = clone(obj[i]); &#125; return copy; &#125; // Handle Object if (obj instanceof Object) &#123; var copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]); &#125; return copy; &#125; throw new Error("Unable to copy obj! Its type isn't supported.");&#125;// 测试用例：// var origin = &#123;// a: "text",// b: null,// c: undefined,// e: &#123;// f: [1, 2]// &#125;// &#125; 组织机构代码验证123456789101112131415161718192021222324252627// 验证规则：// 组织机构代码是每一个机关、社会团体、企事业单位在全国范围内唯一的、始终不变的法定代码标识。最新使用的组织机构代码在1997年颁布实施，由8位数字（或大写拉丁字母）本体代码和1位数字（或大写拉丁字母）校验码组成。本体代码采用系列（即分区段）顺序编码方法。校验码按下列公式计算：8 C9 = 11 - MOD(∑Ci * Wi，11)… (2) i = 1其中：MOD——表示求余函数；i——表示代码字符从左到右位置序号；Ci——表示第i位置上的代码字符的值，采用附录A“代码字符集”所列字符；C9——表示校验码；Wi——表示第i位置上的加权因子，其数值如下表：i 1 2 3 4 5 6 7 8 Wi 3 7 9 10 5 8 4 2当MOD函数值为1（即C9 = 10）时，校验码用字母X表示。// 验证方法：function checkOrgCodeValid(el) &#123; var txtval = el.value; var values = txtval.split("-"); var ws = [3, 7, 9, 10, 5, 8, 4, 2]; var str = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; var reg = /^([0-9A-Z])&#123;8&#125;$/; if (!reg.test(values[0])) &#123; return false &#125; var sum = 0; for (var i = 0; i &lt; 8; i++) &#123; sum += str.indexOf(values[0].charAt(i)) * ws[i]; &#125; var C9 = 11 - (sum % 11); var YC9 = values[1] + ''; if (C9 == 11) &#123; C9 = '0'; &#125; else if (C9 == 10) &#123; C9 = 'X'; &#125; else &#123; C9 = C9 + ''; &#125; return YC9 == C9;&#125; 验证身份证号12345678910/** * 验证身份证号 * @param el 号码输入input * @returns &#123;boolean&#125; */function checkCardNo(el) &#123; var txtval = el.value; var reg = /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/; return reg.test(txtval)&#125; URL有效性验证1234567891011121314151617181920212223/** * URL有效性校验 * @param str_url * @returns &#123;boolean&#125; */function isURL(str_url) &#123; // 验证url var strRegex = "^((https|http|ftp|rtsp|mms)?://)" + "?(([0-9a-z_!~*'().&amp;=+$%-]+: )?[0-9a-z_!~*'().&amp;=+$%-]+@)?" // ftp的user@ + "(([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;" // IP形式的URL- 199.194.52.184 + "|" // 允许IP和DOMAIN（域名） + "([0-9a-z_!~*'()-]+\.)*" // 域名- www. + "([0-9a-z][0-9a-z-]&#123;0,61&#125;)?[0-9a-z]\." // 二级域名 + "[a-z]&#123;2,6&#125;)" // first level domain- .com or .museum + "(:[0-9]&#123;1,4&#125;)?" // 端口- :80 + "((/?)|" // a slash isn't required if there is no file name + "(/[0-9a-z_!~*'().;?:@&amp;=+$,%#-]+)+/?)$"; var re = new RegExp(strRegex); return re.test(str_url);&#125;// 建议的正则functionisURL(str) &#123; return !! str.match(/(((^https?:(?:\/\/)?)(?:[-;:&amp;=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&amp;=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&amp;;%@.\w_]*)#?(?:[\w]*))?)$/g);&#125; 自定义封装jsonp方法12345678910111213141516171819202122232425262728293031323334353637/** * 自定义封装jsonp方法 * @param options */jsonp = function(options) &#123; options = options || &#123;&#125;; if (!options.url || !options.callback) &#123; throw new Error("参数不合法"); &#125; //创建 script 标签并加入到页面中 var callbackName = ('jsonp_' + Math.random()).replace(".", ""); var oHead = document.getElementsByTagName('head')[0]; options.data[options.callback] = callbackName; var params = formatParams(options.data); var oS = document.createElement('script'); oHead.appendChild(oS); //创建jsonp回调函数 window[callbackName] = function(json) &#123; oHead.removeChild(oS); clearTimeout(oS.timer); window[callbackName] = null; options.success &amp;&amp; options.success(json); &#125;; //发送请求 oS.src = options.url + '?' + params; //超时处理 if (options.time) &#123; oS.timer = setTimeout(function() &#123; window[callbackName] = null; oHead.removeChild(oS); options.fail &amp;&amp; options.fail(&#123; message: "超时" &#125;); &#125;, time); &#125;&#125;; 格式化参数123456789101112/** * 格式化参数 * @param data * @returns &#123;string&#125; */formatParams = function(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); &#125; return arr.join('&amp;');&#125; cookie相关操作123456789101112131415161718192021222324252627282930313233//写cookiessetCookie = function(name, value, time) &#123; var strsec = getsec(time); var exp = new Date(); exp.setTime(exp.getTime() + strsec * 1); document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString();&#125;//cookie操作辅助函数getsec = function(str) &#123; var str1 = str.substring(1, str.length) * 1; var str2 = str.substring(0, 1); if (str2 == "s") &#123; return str1 * 1000; &#125; else if (str2 == "h") &#123; return str1 * 60 * 60 * 1000; &#125; else if (str2 == "d") &#123; return str1 * 24 * 60 * 60 * 1000; &#125;&#125;//读取cookiesgetCookie = function(name) &#123; var arr, reg = new RegExp("(^| )" + name + "=([^;]*)(;|$)"); if (arr = document.cookie.match(reg)) return (arr[2]); else return null;&#125;//删除cookiesdelCookie = function(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + "=" + cval + ";expires=" + exp.toGMTString();&#125; 生成随机字符串12345678910111213141516/** * 生成随机字符串(可指定长度) * @param len * @returns &#123;string&#125; */randomString = function(len) &#123; len = len || 8; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125; 判断浏览器123456789101112131415161718192021222324252627282930313233function parseUA() &#123; var u = navigator.userAgent; var u2 = navigator.userAgent.toLowerCase(); return &#123; //移动终端浏览器版本信息 trident: u.indexOf('Trident') &gt; -1, //IE内核 presto: u.indexOf('Presto') &gt; -1, //opera内核 webKit: u.indexOf('AppleWebKit') &gt; -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') &gt; -1 &amp;&amp; u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf('iPhone') &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') &gt; -1, //是否iPad webApp: u.indexOf('Safari') == -1, //是否web应该程序，没有头部与底部 iosv: u.substr(u.indexOf('iPhone OS') + 9, 3), weixin: u2.match(/MicroMessenger/i) == "micromessenger", ali: u.indexOf('AliApp') &gt; -1, &#125;;&#125;// var ua = parseUA();// if (!ua.mobile) &#123;// location.href = './pc.html';// &#125; 获取url后面的参数方法123456789101112function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for (var i = 0; i &lt; strs.length; i++) &#123; theRequest[strs[i].split("=")[0]] = (strs[i].split("=")[1]); &#125; &#125; return theRequest;&#125; 动态加载js1234567891011121314151617181920function loadScript(url, callback) &#123; var script = document.createElement("script"); script.type = "text/"; if (typeof(callback) != "undefined") &#123; if (script.readyState) &#123; script.onreadystatechange = function() &#123; if (script.readyState == "loaded" || script.readyState == "complete") &#123; script.onreadystatechange = null; callback(); &#125; &#125;; &#125; else &#123; script.onload = function() &#123; callback(); &#125;; &#125; &#125; script.src = url; document.body.appendChild(script);&#125; 生成随机颜色123456789function getRandomColor () &#123; const rgb = [] for (let i = 0 ; i &lt; 3; ++i)&#123; let color = Math.floor(Math.random() * 256).toString(16) color = color.length == 1 ? '0' + color : color rgb.push(color) &#125; return '#' + rgb.join('')&#125; 最近几个项目用到就这么多，还会陆续添加的！！！ 参考资料]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多层级组织结构树]]></title>
    <url>%2F2018%2F07%2F13%2FtreeMenu%2F</url>
    <content type="text"><![CDATA[最近公司使用vue开发手机端项目，有个需求是实现派发树，网上找了半天没找到合适的。决定自己撸一个试试，要求多层级，层级不定而且。 正文treeMenu.vue文件123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;ul class=&quot;distributionTree&quot;&gt; &lt;li v-for=&quot;(item,index) in data&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;treeContent0&quot;&gt; &lt;span v-if=&quot;mode==item.orgType || mode==&apos;2&apos;&quot;&gt; &lt;span v-if=&quot;assignType==&apos;1&apos;&quot;&gt; &lt;span class=&quot;checkbox&quot; :class=&quot;&#123;&apos;checkbox_active&apos;:item.checkboxActive&#125;&quot; @click=&quot;item.checkboxActive=!item.checkboxActive&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;span v-else-if=&quot;assignType==&apos;0&apos;&quot;&gt; &lt;span class=&quot;radio&quot; :class=&quot;&#123;&apos;radio_active&apos;:item.radioActive&#125;&quot; @click=&quot;radionToggle(item,data)&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;/span&gt; &lt;label&gt;&#123;&#123;item.text&#125;&#125;&lt;/label&gt; &lt;span class=&quot;nextSet&quot; :class=&quot;&#123;&apos;nextSet_active&apos;:item.nextSetActive&#125;&quot; v-if=&quot;item.orgType!=&apos;0&apos;&quot; @click=&quot;toggle(item, index)&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;tree-menu v-on=&quot;$listeners&quot; :data=&quot;item.org&quot; :assignType=&quot;assignType&quot; :mode=&quot;mode&quot; v-if=&quot;item.nextSetActive&quot;&gt;&lt;/tree-menu&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; data就是派发树的内容，我们项目实际需要判断是否显示单选钮和多选钮，通过orgType 和mode判断，orgType 是每一条数据里的一项，mode是上一层传过来的数据信息。然后通过assignType判断是单选钮还是多选钮，当然assignType也是上一层调用树组件传过来的数据啦。其中用到了一个知识点：v-on=”$listeners”，用来监听多层级树中的事件。之前写的一篇文章有介绍该内容vue项目技术随笔，欢迎阅读。一些相关的methods如下: 1234567891011121314151617methods:&#123; toggle (item, index) &#123; item.nextSetActive=!item.nextSetActive; if (item.org==null ||item.org.length==0) &#123; Indicator.open(&apos;加载中...&apos;); this.$emit(&apos;getsubmenu&apos;, item,()=&gt;&#123; Indicator.close(); &#125;); &#125; &#125;, radionToggle(item,data)&#123; data.forEach((e,index)=&gt;&#123; e.radioActive=false; &#125;); item.radioActive=!item.radioActive; &#125;&#125; 该移动端项目中使用了mintui作为ui框架，使用了其中的加载效果，点击展现下一层级的时候出现加载中，提升用户体验。toggle作用展示和隐藏下一层级，如果下一层级没有数据，需要触发动作去取数据，呈现加载中，取到数据后，回调函数，让加载中提示效果消失。radionToggle方法就是实现单选钮的选中效果了，很简单。看一下最终的效果呈现：具体的css就靠大家自己发挥了，不同的设计不同的css，感谢大家的支持。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目开发记录随笔]]></title>
    <url>%2F2018%2F07%2F12%2FvueDevDiary1%2F</url>
    <content type="text"><![CDATA[最近都在做vue相关的项目，在公司推行前后端分离，重构以前的项目，真的好忙，一个项目接着一个，爬不完的坑，不说了，说多了都是眼泪。开始正文了！！！ Vue 路由切换时页面内容没有重新加载问题原因：在组件mounted钩子中调用的刷新页面内容，但测试发现这个钩子没有被调用。后来发现App.vue中使用了：keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。这就是问题所在了。 解决办法： 使用Vue组件切换过程钩子activated(keep-alive组件激活时调用)，而不是挂载钩子mounted： 12345678&lt;script&gt;export default &#123; activated: function() &#123; this.getData() &#125;&#125;&lt;/script&gt; 参考网址关于keep-alive组件的钩子：https://cn.vuejs.org/v2/api/#activated 文件导出方式项目中涉及到文件导出，分xml和excel导出。不同的文件导出格式不同，需要根据文件类型判断导出格式。 1234567891011121314151617181920212223242526272829303132exportAllData(val)&#123; //全部导出 if(!val)&#123; this.exportFile(this.exportAllType); &#125;&#125;,exportFile(exportType)&#123; let url=&apos;&apos;;//接口地址 this.$axios.get(url,&#123;responseType: &apos;arraybuffer&apos;&#125;).then(res =&gt; &#123; this.download(res.data,exportType); &#125;,res =&gt; &#123; this.$Message.error(&apos;导出失败&apos;); &#125;);&#125;,download (data,exportType) &#123; if (!data) &#123; return &#125; let exportGs=&apos;&apos;; if(exportType===&apos;excel&apos;)&#123; exportGs=&apos;application/vnd.ms-excel&apos;; &#125;else if(exportType===&apos;xml&apos;)&#123; exportGs=&apos;text/xml&apos;; &#125; let url = window.URL.createObjectURL(new Blob([data],&#123;type: exportGs&#125;)); let link = document.createElement(&apos;a&apos;) link.style.display = &apos;none&apos; link.href = url; link.setAttribute(&apos;download&apos;, &apos;文件&apos;); document.body.appendChild(link) link.click(); &#125; 在vue多层次组件监听动作和属性的时候可以使用如下方式进行监听1v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; Vue 2.4 版本提供了这种方法，将父组件中不被认为 props特性绑定的属性传入子组件中，通常配合 interitAttrs 选项一起使用。之所以要提到这两个属性，是因为两者的出现使得组件之间跨组件的通信在不依赖 vuex 和事件总线的情况下变得简洁，业务清晰。 比如组件A=&gt;B组件=&gt;C组件等，这种多层级组件，A组件向C组件传递数据或者C组件的事件要触发A组件中的事件的话，就可以在B组件中写成12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;child1&#125;&#125;&lt;span&gt; &lt;!-- C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt; &lt;c v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/c&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import c from &apos;./c.vue&apos;; export default &#123; props: [&apos;child1&apos;], data () &#123; return &#123;&#125;; &#125;, inheritAttrs: false, components: &#123; c &#125;, mounted () &#123; this.$emit(&apos;test1&apos;); &#125; &#125;;&lt;/script&gt; C组件1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;span&gt;&#123;&#123;child2&#125;&#125;&lt;span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [child2&apos;], data () &#123; return &#123;&#125;; &#125;, inheritAttrs: false, mounted () &#123; this.$emit(&apos;test2&apos;); &#125; &#125;;&lt;/script&gt; A组件：12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;b :child1=&quot;child1&quot; :child2=&quot;child2&quot; @test1=&quot;test1&quot; @test2=&quot;test2&quot;&gt;&lt;/b&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import b from &apos;./b.vue&apos;; export default &#123; data () &#123; return &#123; child1:&apos;hello child1&apos;, child2:&apos;hello child2&apos; &#125;; &#125;, components: &#123; b &#125;, methods: &#123; test1 () &#123; console.log(&apos;test1&apos;); &#125;, test2 () &#123; console.log(&apos;test2&apos;); &#125; &#125; &#125;;&lt;/script&gt; 记录日常开发中用到的一些知识点，权当一次总结吧。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+iview项目开发实践问题总结（一）]]></title>
    <url>%2F2018%2F06%2F08%2FiviewDevelopDiary%2F</url>
    <content type="text"><![CDATA[记录一次项目中使用vue+iview开发的问题，权当一次总结吧！ 1.实际使用中需要监听对象变化或者对象数组中某一属性是否发生变化 1234567891011121314151617181920212223242526272829data()&#123; return &#123; associationNewForm:&#123;...&#125; &#125;&#125;,watch:&#123; // [&apos;associationNewForm.ruleName&apos;]()&#123; //监听某一属性发生变化 // this.$emit(&apos;datachange&apos;,this.associationNewForm); // &#125; associationNewForm:&#123; handler:function(val, oldVal)&#123; this.$emit(&apos;datachange&apos;,val);//通知父组件数据变化 &#125;, deep:true &#125; &#125;,configStepData:&#123;//监听对象数组属性变化，需要深度监听handler: function (newVal) &#123; let dataObj=&#123; flag:&apos;zgjconfigStepData&apos;, data:this.configStepData &#125;; this.$emit(&apos;getSubAlarmConditionData&apos;,dataObj);&#125;,deep: true //深度监听&#125; 2.iview中表格渲染行的事件阻止冒泡方式 12345on: &#123;click: e =&gt; &#123; e.stopPropagation(); this.removeRow(params);&#125;&#125; 3.iview中modal点击确定的操作时，但是modal中有表单校验，这个时候就需要通过loading动态控制123456789ok () &#123; this.$Message.info(&apos;异步验证数据&apos;); setTimeout(() =&gt; &#123; this.loading = false; this.$nextTick(() =&gt; &#123; this.loading = true; &#125;); &#125;, 2000);&#125; iview的github上有对应的issue有对应问题，相关issue 4.iview中时间选择组件如果需要禁用的话，单独添加disabled不起作用，需要添加readonly 5.iview中table列开启了ellipsis鼠标滑过显示tooltip,网上找到一种方法，显示内容 123456789101112131415161718192021&#123; title: &apos;属性值&apos;, key: &apos;attrValue&apos;, render: (h, params) =&gt; &#123; return h(&apos;div&apos;, [ h(&apos;span&apos;, &#123; style: &#123; display: &apos;inline-block&apos;, width: &apos;100%&apos;, overflow: &apos;hidden&apos;, textOverflow: &apos;ellipsis&apos;, whiteSpace: &apos;nowrap&apos; &#125;, domProps: &#123; title: params.row.attrValue &#125; &#125;, params.row.attrValue) ]); &#125; &#125; 在iview的github上有对应issue，但是没有得到解决,上面好多人都在问，稍微吐槽下，感觉处理问题不如element-ui框架团队处理的快，个人更喜好element。 自己鼓捣出了一种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; title: &apos;属性值&apos;, key: &apos;attrValue&apos;, ellipsis:true, render: (h, params) =&gt; &#123; return h(&apos;div&apos;, [ // h(&apos;span&apos;, &#123; // style: &#123; // display: &apos;inline-block&apos;, // width: &apos;100%&apos;, // overflow: &apos;hidden&apos;, // textOverflow: &apos;ellipsis&apos;, // whiteSpace: &apos;nowrap&apos; // &#125;, // domProps: &#123; // title: params.row.attrValue // &#125; // &#125;, params.row.attrValue) h( &apos;Tooltip&apos;, &#123; props: &#123; content: params.row.attrValue, placement: &apos;top-start&apos;, transfer: true &#125;, style:&#123; width:&apos;100%&apos; &#125; &#125;, [ h(&apos;span&apos;, &#123; style: &#123; display: &apos;inline-block&apos;, width: &apos;100%&apos;, overflow: &apos;hidden&apos;, textOverflow: &apos;ellipsis&apos;, whiteSpace: &apos;nowrap&apos; &#125;, on: &#123; click: () =&gt; &#123; this.toUpdate(params.index); &#125; &#125; &#125;,params.row.attrValue) ] ) ]); &#125; &#125; 不过需要配合样式才能正常实现 123456.ivu-tooltip-inner&#123; white-space:normal; &#125; .ivu-tooltip-rel&#123; display: block; &#125; 初次使用iview，还在不断摸索中，后续如果有问题的话，会持续更新。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题内接入网页在线聊天功能]]></title>
    <url>%2F2018%2F05%2F27%2FhexoThemesChatSetting%2F</url>
    <content type="text"><![CDATA[访问别人博客的过程中发现别人的博客有聊天功能，看着挺不错。研究了下，给自己的博客页也加上类似的功能，特此记录。 注册首先需要去DaoVoice注册账号，注册邀请链接 完成后，会得到一个app_id，后面会用到： 1234daovoice(&apos;init&apos;, &#123; app_id: &quot;***&quot;&#125;);daovoice(&apos;update&apos;); 保存好这个id值，后面会用到。 修改head.swig修改/themes/next/layout/_partials/head.swig文件，添加内容如下： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 配置主题文件在_config.yml文件中添加内容： 123# Online contactdaovoice: truedaovoice_app_id: # 这里填你刚才获得的 app_id 基本上大功告成了，之后hexo命令重新生成发布即可。如果需要进行聊天窗口配置的话，也可以在浏览器中登录daoVoice后在控制面板中配置。 有什么问题的话欢迎留言哦 ！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀站点集合]]></title>
    <url>%2F2018%2F05%2F25%2FgoodResource%2F</url>
    <content type="text"><![CDATA[记录日常资源，优秀的站点，便于日后查找，以后还会陆续添加。 前端导航 前端技术导航 腾讯前端技术导航 前端导航平台 前端学习资源 github资源收集 大前端网址导航 前端大神俱乐部 前端导航站 前端开发博客集合 前端收藏夹 前端导航网 前端学习资源汇总 UI设计师导航 常用技术网站整理 前端人的俱乐部 大前端工具集 前端收集箱 前端资源库]]></content>
      <categories>
        <category>资源合集</category>
      </categories>
      <tags>
        <tag>resource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tab切换巧妙布局]]></title>
    <url>%2F2018%2F05%2F19%2FtabDemo%2F</url>
    <content type="text"><![CDATA[一个项目中用到了tab切换，无奈内容太多，不能按照往常的一般形式排列tab。UI设计了一种类似于蜂巢的tab切换。如图所示代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;蜂巢tab切换实例&lt;/title&gt; &lt;meta http-equiv=&quot;keywords&quot; content=&quot;&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=”IE=Edge,chrome=1″ /&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .Ct&#123; width:1000px; margin:0 auto; &#125;.ywPart1&#123; width: 310px; margin: 0 auto; padding: 20px 10px 20px 30px;&#125;/**蜂巢样式***/.hex &#123; float: left; margin-left: 2px; margin-bottom: -18px; cursor: pointer; &#125; .hex .hex_top &#123; width: 0; border-bottom: 20px solid #f0f0f0; border-left: 35px solid transparent; border-right: 35px solid transparent; margin-top: -1px\9\0; margin-top: 0px\0; &#125; .hex .hex_middle &#123; width: 70px; height: 30px; line-height: 30px; background: #f0f0f0; text-align: center; font-family: &quot;宋体&quot;; color: #333333; &#125; .hex .hex_bottom &#123; width: 0; border-top: 20px solid #f0f0f0; border-left: 35px solid transparent; border-right: 35px solid transparent; margin-top: -1px\9\0; margin-top: 0px\0; &#125; .hex-row &#123; clear: left; &#125; .hex-row.even &#123; margin-left: 38px; &#125;.hex-row.odd &#123; margin-right: 38px; &#125;.hex.hexActive .hex_top &#123; width: 0; border-bottom: 20px solid #86ccac; border-left: 35px solid transparent; border-right: 35px solid transparent; margin-top: -1px\9\0; margin-top: 0px\0; &#125; .hex.hexActive .hex_middle &#123; width: 70px; height: 30px; line-height: 30px; background: #86ccac; text-align: center; font-family: &quot;宋体&quot;; color: #FFFFFF; &#125; .hex.hexActive .hex_bottom &#123; width: 0; border-top: 20px solid #86ccac; border-left: 35px solid transparent; border-right: 35px solid transparent; margin-top: -1px\9\0; margin-top: 0px\0; &#125;/**蜂巢样式***/ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;Ct&quot;&gt; &lt;div class=&quot;ywPart1&quot; id=&quot;hexDiv&quot;&gt; &lt;!-- 描述：蜂巢 --&gt; &lt;div class=&quot;hex hexActive&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;即时通信&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;阅读&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;微博&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;导航&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex hex-row even&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;视频&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;音乐&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;应用商店&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex hex-row&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;游戏&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;支付&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;动漫&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;P2P业务&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex hex-row even&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;VOIP业务&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;彩信&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;浏览下载&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex hex-row&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;财经&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;安全杀毒&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;邮箱&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;hex&quot; name=&quot;hexBlcok&quot;&gt; &lt;div class=&quot;hex_top&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hex_middle&quot;&gt;其他&lt;/div&gt; &lt;div class=&quot;hex_bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;ClearFloat&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(&quot;#hexDiv&quot;).find(&quot;div[name=&apos;hexBlcok&apos;]&quot;).on(&quot;click&quot;,function()&#123; $(this).addClass(&quot;hexActive&quot;); $(this).siblings(&quot;div[name=&apos;hexBlcok&apos;]&quot;).removeClass(&quot;hexActive&quot;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆环周围均匀分布内容]]></title>
    <url>%2F2018%2F05%2F18%2Fcircle%2F</url>
    <content type="text"><![CDATA[逐渐迁移别的技术论坛博文到该博客，这是之前写的一篇文章。项目中用到了一个圆环周围均匀分布内容。直接上代码，毕竟对程序员来说talk is cheap,show me code. &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=”IE=Edge,chrome=1″ /&gt;&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;title&gt;无标题&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .centerDiv{ width:600px; height:600px; margin:0 auto; margin-top:200px; position:relative; } .dashedCircle{ height:300px; width:300px; border-radius: 100%; border: 1px dashed #494949; margin: 0 auto; } .circle,.circleCenter{ width:40px; height:40px; line-height:40px; text-align:center; color:#fff; background:#97e49a; border-radius: 100%; position: absolute; } .circleCenter{ width:20px; height:20px; line-height:20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;centerDiv&quot;&gt; &lt;div class=&quot;dashedCircle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circleCenter&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;12&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;10&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;8&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function(){ var dx=280, dy=130, s=180,//半径 x=Math.sin(0), y=Math.cos(0), dig=2*Math.PI/12; var circle=document.querySelectorAll(&quot;.circle&quot;); for(var i=0;i&lt;12;i++){ var x=Math.sin(i*dig); var y=Math.cos(i*dig); var topValue=Number(dy+y*s), leftValue=Number(dx+x*s); circle[i].style.top=topValue+&quot;px&quot;; circle[i].style.left=leftValue+&quot;px&quot;; } var circleCenterObj=document.querySelector(&quot;.circleCenter&quot;); circleCenterObj.style.top=Number(dy)+10;//10是中心小圆半径 circleCenterObj.style.left=Number(dx)+10; } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 钟表]]></title>
    <url>%2F2018%2F05%2F17%2Fcss-clock%2F</url>
    <content type="text"><![CDATA[第一篇博文，就把以前的文章发上来试试吧。直接上代码。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;钟表&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background-color:#00A2D4; } .clock { width: 200px; height: 200px; background: -webkit-radial-gradient(#3b3b3b, #000); background: radial-gradient(#2E3F50, #0E1B29); box-shadow: inset 0px 0px 30px #131313, 0px 2px 18px rgba(0,0,0,0.5); border: 6px solid #172839; border-radius: 106px; margin: auto; position: absolute; top: 0; bottom: 0; left: 0; right: 0; } .hour-hand { width: 4px; height: 55px; background: #fff; box-shadow: 0px 0px 7px #000; position: absolute; top: 45px; left: 98px; } .minute-hand { width: 4px; height: 80px; background: #fff; box-shadow: 0px 0px 4px #000; position: absolute; top: 20px; left: 98px; } .second-hand { width: 2px; height: 80px; background: #bbb; box-shadow: 0px 0px 7px #000; position: absolute; top: 20px; left: 99px; } .pin { width: 10px; height: 10px; background: #222; border-radius: 10px; margin: auto; position: absolute; top: 0; bottom: 0; left: 0; right: 0; } .hour-hand, .minute-hand, .second-hand { -webkit-transform-origin: 50% 100%; -moz-transform-origin: 50% 100%; -o-transform-origin: 50% 100%; -ms-transform-origin: 50% 100%; transform-origin: 50% 100%; } .circle{ width:20px; height:20px; line-height:20px; text-align:center; color:#fff; position: absolute; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;clock&quot;&gt; &lt;div class=&quot;minute-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;hour-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;second-hand&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pin&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;12&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;11&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;10&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;7&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function(){ setInterval(function(){ var dt = new Date(); var sec_deg = dt.getSeconds() * (360/60); var min_deg = dt.getMinutes() * (360/60); var hr_deg = dt.getHours() * (360/12) + dt.getMinutes() * (360/60/12); document.querySelector(&quot;.clock .second-hand&quot;).style.cssText=&apos;-webkit-transform:rotate(&apos; + sec_deg + &apos;deg)&apos;,&apos;-moz-transform:rotate(&apos; + sec_deg + &apos;deg)&apos;, &apos;-o-transform:rotate(&apos; + sec_deg + &apos;deg)&apos;, &apos;-ms-transform:rotate(&apos; + sec_deg + &apos;deg)&apos;, &apos;transform:rotate(&apos; + sec_deg + &apos;deg)&apos;; document.querySelector(&apos;.clock .minute-hand&apos;).style.cssText=&apos;-webkit-transform:rotate(&apos; + min_deg + &apos;deg)&apos;, &apos;-moz-transform:rotate(&apos; + min_deg + &apos;deg)&apos;, &apos;-o-transform:rotate(&apos; + min_deg + &apos;deg)&apos;, &apos;-ms-transform:rotate(&apos; + min_deg + &apos;deg)&apos;, &apos;transform:rotate(&apos; + min_deg + &apos;deg)&apos;; document.querySelector(&apos;.clock .hour-hand&apos;).style.cssText=&apos;-webkit-transform:rotate(&apos; + hr_deg + &apos;deg)&apos;, &apos;-moz-transform:rotate(&apos; + hr_deg + &apos;deg)&apos;, &apos;-o-transform:rotate(&apos; + hr_deg + &apos;deg)&apos;, &apos;-ms-transform:rotate(&apos; + hr_deg + &apos;deg)&apos;, &apos;transform:rotate(&apos; + hr_deg + &apos;deg)&apos;; }, 1000); var dx=90, dy=90, s=87,//半径 x=Math.sin(0), y=Math.cos(0), dig=2*Math.PI/12; var circle=document.querySelectorAll(&quot;.circle&quot;); for(var i=0;i&lt;12;i++){ var x=Math.sin(i*dig); var y=Math.cos(i*dig); var topValue=Number(dy+y*s), leftValue=Number(dx+x*s); circle[i].style.top=topValue+&quot;px&quot;; circle[i].style.left=leftValue+&quot;px&quot;; } } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
</search>
